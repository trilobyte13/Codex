package com.example.byzantine;

import javax.imageio.ImageIO;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Font;
import java.awt.GradientPaint;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.TexturePaint;
import java.awt.geom.Line2D;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Deque;
import java.util.EnumSet;
import java.util.List;
import java.util.Random;

/**
 * Generates a randomly decorated Byzantine city block floor plan.
 *
 * <p>The generator combines late Roman and medieval inspired building layouts by
 * carving streets and alleys into a block and allocating parcels for different
 * building archetypes such as private houses, insulae (tenements), churches,
 * shops and green spaces. The output is written to {@code byzantine_city_block.png}.</p>
 */
public class ByzantineCityBlockGenerator {

    private static final int IMAGE_WIDTH = 900;
    private static final int IMAGE_HEIGHT = 900;
    private static final int MARGIN = 40;
    private static final int PERIMETER_ROAD = 70;
    private static final int MIN_PARCEL_SIZE = 90;
    private static final int ROAD_WIDTH_MIN = 12;
    private static final int ROAD_WIDTH_MAX = 26;
    private static final Color BACKGROUND_COLOR = new Color(238, 232, 213);
    private static final Color ROAD_COLOR = new Color(176, 159, 132);
    private static final Color ALLEY_COLOR = new Color(205, 186, 154);
    private static final Font LABEL_FONT = new Font("Serif", Font.BOLD, 14);
    private static final Color FLOOR_TONE = new Color(220, 209, 186);
    private static final Color WALL_TONE = new Color(109, 78, 55);
    private static final Color WALKWAY_TONE = new Color(214, 198, 163);

    private final Random random;
    private Rectangle2D.Double buildableArea;
    private List<Road> currentRoads;

    private ByzantineCityBlockGenerator(long seed) {
        this.random = new Random(seed);
    }

    public static void main(String[] args) throws IOException {
        long seed = System.currentTimeMillis();
        ByzantineCityBlockGenerator generator = new ByzantineCityBlockGenerator(seed);
        BufferedImage image = generator.createPlan();
        ImageIO.write(image, "png", new File("byzantine_city_block.png"));
        System.out.println("Generated byzantine_city_block.png with seed " + seed);
    }

    private BufferedImage createPlan() {
        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g = image.createGraphics();
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        g.setColor(BACKGROUND_COLOR);
        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);

        Rectangle2D.Double block = new Rectangle2D.Double(MARGIN, MARGIN, IMAGE_WIDTH - 2 * MARGIN, IMAGE_HEIGHT - 2 * MARGIN);
        Rectangle2D.Double buildable = new Rectangle2D.Double(
                block.x + PERIMETER_ROAD,
                block.y + PERIMETER_ROAD,
                block.width - 2 * PERIMETER_ROAD,
                block.height - 2 * PERIMETER_ROAD
        );
        this.buildableArea = buildable;

        drawPerimeterRoad(g, block, buildable);

        List<Road> innerRoads = new ArrayList<Road>();
        List<Parcel> parcels = subdivideBlock(buildable, innerRoads);
        this.currentRoads = innerRoads;
        ensureRequiredBuildingTypes(parcels);

        drawInnerRoads(g, innerRoads);
        drawParcels(g, parcels);
        annotateParcels(g, parcels);

        g.dispose();
        return image;
    }

    private void drawPerimeterRoad(Graphics2D g, Rectangle2D.Double block, Rectangle2D.Double buildable) {
        g.setColor(ROAD_COLOR);
        g.fill(block);
        g.setColor(new Color(210, 195, 166));
        g.setStroke(new BasicStroke(6f));
        g.draw(block);

        g.setColor(BACKGROUND_COLOR);
        g.fill(buildable);

        // Add a radial gradient hinting at worn paving.
        Graphics2D g2 = (Graphics2D) g.create();
        int gradientRadius = (int) Math.max(block.width, block.height);
        GradientPaint gradient = new GradientPaint(
                (float) (block.getCenterX()), (float) (block.getCenterY()), new Color(193, 178, 152, 90),
                (float) (block.getCenterX()), (float) (block.getCenterY() + gradientRadius), new Color(150, 130, 100, 0)
        );
        g2.setPaint(gradient);
        g2.fill(block);
        g2.dispose();
    }

    private List<Parcel> subdivideBlock(Rectangle2D.Double buildable, List<Road> innerRoads) {
        List<Parcel> parcels = new ArrayList<Parcel>();
        Deque<Rectangle2D.Double> queue = new ArrayDeque<Rectangle2D.Double>();
        queue.add(buildable);

        while (!queue.isEmpty()) {
            Rectangle2D.Double current = queue.removeFirst();
            if (shouldSplit(current)) {
                boolean splitVertical = decideSplitOrientation(current);
                double roadWidth = randomRange(ROAD_WIDTH_MIN, ROAD_WIDTH_MAX);

                if (splitVertical) {
                    double splitX = randomSplitCoordinate(current.x, current.x + current.width, roadWidth);
                    Rectangle2D.Double left = new Rectangle2D.Double(current.x, current.y,
                            splitX - roadWidth / 2.0 - current.x, current.height);
                    Rectangle2D.Double right = new Rectangle2D.Double(splitX + roadWidth / 2.0, current.y,
                            current.x + current.width - (splitX + roadWidth / 2.0), current.height);
                    Rectangle2D.Double roadRect = new Rectangle2D.Double(splitX - roadWidth / 2.0, current.y, roadWidth, current.height);
                    innerRoads.add(new Road(roadRect, roadWidth));
                    enqueueIfValid(queue, left);
                    enqueueIfValid(queue, right);
                } else {
                    double splitY = randomSplitCoordinate(current.y, current.y + current.height, roadWidth);
                    Rectangle2D.Double top = new Rectangle2D.Double(current.x, current.y, current.width,
                            splitY - roadWidth / 2.0 - current.y);
                    Rectangle2D.Double bottom = new Rectangle2D.Double(current.x, splitY + roadWidth / 2.0, current.width,
                            current.y + current.height - (splitY + roadWidth / 2.0));
                    Rectangle2D.Double roadRect = new Rectangle2D.Double(current.x, splitY - roadWidth / 2.0, current.width, roadWidth);
                    innerRoads.add(new Road(roadRect, roadWidth));
                    enqueueIfValid(queue, top);
                    enqueueIfValid(queue, bottom);
                }
            } else {
                parcels.add(new Parcel(current));
            }
        }
        return parcels;
    }

    private boolean shouldSplit(Rectangle2D.Double rect) {
        double largestSide = Math.max(rect.width, rect.height);
        double smallestSide = Math.min(rect.width, rect.height);
        if (largestSide < MIN_PARCEL_SIZE * 1.5) {
            return false;
        }
        if (smallestSide < MIN_PARCEL_SIZE) {
            return false;
        }
        double probability = 0.35 + 0.3 * (largestSide / (buildableExtent()));
        return random.nextDouble() < probability;
    }

    private boolean decideSplitOrientation(Rectangle2D.Double rect) {
        if (rect.width > rect.height * 1.4) {
            return true;
        }
        if (rect.height > rect.width * 1.4) {
            return false;
        }
        return random.nextBoolean();
    }

    private double randomSplitCoordinate(double minEdge, double maxEdge, double roadWidth) {
        double min = minEdge + MIN_PARCEL_SIZE + roadWidth / 2.0;
        double max = maxEdge - MIN_PARCEL_SIZE - roadWidth / 2.0;
        if (max <= min) {
            return (minEdge + maxEdge) / 2.0;
        }
        return min + random.nextDouble() * (max - min);
    }

    private void enqueueIfValid(Deque<Rectangle2D.Double> queue, Rectangle2D.Double rect) {
        if (rect.width > 30 && rect.height > 30) {
            queue.add(rect);
        }
    }

    private double buildableExtent() {
        return IMAGE_WIDTH - 2 * (MARGIN + PERIMETER_ROAD);
    }

    private void ensureRequiredBuildingTypes(List<Parcel> parcels) {
        Collections.sort(parcels, new Comparator<Parcel>() {
            @Override
            public int compare(Parcel o1, Parcel o2) {
                double area1 = o1.area();
                double area2 = o2.area();
                return Double.compare(area2, area1);
            }
        });

        if (parcels.isEmpty()) {
            return;
        }

        Parcel churchParcel = chooseCentralParcel(parcels);
        churchParcel.type = BuildingType.CHURCH;

        int tenements = Math.max(1, parcels.size() / 6);
        int assignedTenements = assignLargestParcels(parcels, BuildingType.TENEMENT, tenements, churchParcel);
        if (assignedTenements == 0) {
            assignFallbackByArea(parcels, BuildingType.TENEMENT, churchParcel);
        }

        Parcel parkParcel = chooseParkParcel(parcels, churchParcel);
        if (parkParcel != null && parkParcel.type == BuildingType.UNASSIGNED) {
            parkParcel.type = BuildingType.PARK;
        }

        assignShops(parcels);
        assignHouses(parcels);
        assignRemaining(parcels);

        ensureTypePresence(parcels, BuildingType.PARK, parkParcel);
        ensureTypePresence(parcels, BuildingType.SHOP, null);
        ensureTypePresence(parcels, BuildingType.PRIVATE_HOUSE, null);
        ensureTypePresence(parcels, BuildingType.TENEMENT, churchParcel);
    }

    private Parcel chooseCentralParcel(List<Parcel> parcels) {
        double centerX = IMAGE_WIDTH / 2.0;
        double centerY = IMAGE_HEIGHT / 2.0;
        Parcel best = parcels.get(0);
        double bestScore = Double.MAX_VALUE;
        for (Parcel parcel : parcels) {
            double dx = parcel.rect.getCenterX() - centerX;
            double dy = parcel.rect.getCenterY() - centerY;
            double distance = Math.hypot(dx, dy);
            double areaScore = parcel.area();
            double score = distance * 0.7 - areaScore * 0.0005;
            if (parcel.type == BuildingType.UNASSIGNED && score < bestScore) {
                bestScore = score;
                best = parcel;
            }
        }
        return best;
    }

    private int assignLargestParcels(List<Parcel> parcels, BuildingType type, int count, Parcel exclude) {
        int assigned = 0;
        for (Parcel parcel : parcels) {
            if (parcel == exclude) {
                continue;
            }
            if (parcel.type == BuildingType.UNASSIGNED && parcel.area() > 14000) {
                parcel.type = type;
                assigned++;
            }
            if (assigned >= count) {
                break;
            }
        }
        return assigned;
    }

    private void assignFallbackByArea(List<Parcel> parcels, BuildingType type, Parcel exclude) {
        for (Parcel parcel : parcels) {
            if (parcel != exclude && parcel.type == BuildingType.UNASSIGNED) {
                parcel.type = type;
                return;
            }
        }
    }

    private Parcel chooseParkParcel(List<Parcel> parcels, Parcel churchParcel) {
        Parcel candidate = null;
        double bestScore = Double.NEGATIVE_INFINITY;
        for (Parcel parcel : parcels) {
            if (parcel == churchParcel || parcel.type != BuildingType.UNASSIGNED) {
                continue;
            }
            double openScore = 1.0 / (1.0 + Math.abs(parcel.rect.width - parcel.rect.height));
            double borderScore = Math.min(distanceToEdge(parcel.rect), 120);
            double areaScore = Math.log(Math.max(parcel.area(), 1));
            double score = openScore * 1.2 + borderScore * 0.015 + areaScore * 0.12;
            if (score > bestScore) {
                bestScore = score;
                candidate = parcel;
            }
        }
        return candidate;
    }

    private double distanceToEdge(Rectangle2D.Double rect) {
        double left = rect.x - MARGIN;
        double right = IMAGE_WIDTH - MARGIN - (rect.x + rect.width);
        double top = rect.y - MARGIN;
        double bottom = IMAGE_HEIGHT - MARGIN - (rect.y + rect.height);
        return Math.min(Math.min(left, right), Math.min(top, bottom));
    }

    private void assignShops(List<Parcel> parcels) {
        List<Parcel> candidates = new ArrayList<Parcel>();
        for (Parcel parcel : parcels) {
            if (parcel.type == BuildingType.UNASSIGNED && Math.min(parcel.rect.width, parcel.rect.height) < 140) {
                candidates.add(parcel);
            }
        }
        if (candidates.isEmpty()) {
            for (Parcel parcel : parcels) {
                if (parcel.type == BuildingType.UNASSIGNED) {
                    candidates.add(parcel);
                }
            }
        }
        int shops = Math.max(2, parcels.size() / 8);
        Collections.shuffle(candidates, random);
        for (int i = 0; i < Math.min(shops, candidates.size()); i++) {
            candidates.get(i).type = BuildingType.SHOP;
        }
    }

    private void assignHouses(List<Parcel> parcels) {
        for (Parcel parcel : parcels) {
            if (parcel.type == BuildingType.UNASSIGNED && parcel.area() < 22000) {
                parcel.type = BuildingType.PRIVATE_HOUSE;
            }
        }
    }

    private void assignRemaining(List<Parcel> parcels) {
        for (Parcel parcel : parcels) {
            if (parcel.type == BuildingType.UNASSIGNED) {
                if (parcel.area() > 26000) {
                    parcel.type = BuildingType.TENEMENT;
                } else if (random.nextDouble() < 0.3) {
                    parcel.type = BuildingType.PARK;
                } else {
                    parcel.type = BuildingType.PRIVATE_HOUSE;
                }
            }
        }
    }

    private void ensureTypePresence(List<Parcel> parcels, BuildingType type, Parcel exclude) {
        if (hasType(parcels, type)) {
            return;
        }
        switch (type) {
            case PARK:
                Parcel parkCandidate = chooseParkParcel(parcels, exclude);
                if (parkCandidate != null) {
                    parkCandidate.type = BuildingType.PARK;
                }
                break;
            case SHOP:
                Parcel shopCandidate = findBestByComparator(parcels, new Comparator<Parcel>() {
                    @Override
                    public int compare(Parcel a, Parcel b) {
                        double scoreA = Math.min(a.rect.width, a.rect.height);
                        double scoreB = Math.min(b.rect.width, b.rect.height);
                        return Double.compare(scoreA, scoreB);
                    }
                }, exclude);
                if (shopCandidate != null) {
                    shopCandidate.type = BuildingType.SHOP;
                }
                break;
            case PRIVATE_HOUSE:
                Parcel houseCandidate = findBestByComparator(parcels, new Comparator<Parcel>() {
                    @Override
                    public int compare(Parcel a, Parcel b) {
                        return Double.compare(Math.abs(a.area() - 15000), Math.abs(b.area() - 15000));
                    }
                }, exclude);
                if (houseCandidate != null) {
                    houseCandidate.type = BuildingType.PRIVATE_HOUSE;
                }
                break;
            case TENEMENT:
                Parcel tenementCandidate = findBestByComparator(parcels, new Comparator<Parcel>() {
                    @Override
                    public int compare(Parcel a, Parcel b) {
                        return Double.compare(b.area(), a.area());
                    }
                }, exclude);
                if (tenementCandidate != null) {
                    tenementCandidate.type = BuildingType.TENEMENT;
                }
                break;
            default:
                break;
        }
    }

    private boolean hasType(List<Parcel> parcels, BuildingType type) {
        for (Parcel parcel : parcels) {
            if (parcel.type == type) {
                return true;
            }
        }
        return false;
    }

    private Parcel findBestByComparator(List<Parcel> parcels, Comparator<Parcel> comparator, Parcel exclude) {
        Parcel best = null;
        for (Parcel parcel : parcels) {
            if (parcel == exclude || parcel.type == BuildingType.CHURCH) {
                continue;
            }
            if (best == null) {
                best = parcel;
                continue;
            }
            int penaltyBest = typePenalty(best.type);
            int penaltyParcel = typePenalty(parcel.type);
            if (penaltyParcel != penaltyBest) {
                if (penaltyParcel < penaltyBest) {
                    best = parcel;
                }
            } else if (comparator.compare(parcel, best) < 0) {
                best = parcel;
            }
        }
        return best;
    }

    private int typePenalty(BuildingType type) {
        if (type == BuildingType.UNASSIGNED) {
            return 0;
        }
        if (type == BuildingType.PRIVATE_HOUSE) {
            return 1;
        }
        if (type == BuildingType.PARK || type == BuildingType.SHOP) {
            return 2;
        }
        if (type == BuildingType.TENEMENT) {
            return 3;
        }
        return 4;
    }

    private void drawInnerRoads(Graphics2D g, List<Road> innerRoads) {
        g.setColor(ALLEY_COLOR);
        for (Road road : innerRoads) {
            g.fill(road.rect);
            Graphics2D g2 = (Graphics2D) g.create();
            g2.setColor(new Color(180, 160, 130));
            g2.setStroke(new BasicStroke(Math.max(2f, (float) (road.width / 4.5))));
            g2.draw(road.rect);
            g2.dispose();
        }
    }

    private void drawParcels(Graphics2D g, List<Parcel> parcels) {
        for (Parcel parcel : parcels) {
            BuildingType type = parcel.type != null ? parcel.type : BuildingType.PRIVATE_HOUSE;
            g.setColor(type.fillColor);
            g.fill(parcel.rect);

            Graphics2D planGraphics = (Graphics2D) g.create();
            planGraphics.clip(parcel.rect);
            Edge entrance = findEntranceSide(parcel);
            EnumSet<Edge> partyWalls = findPartyWalls(parcel, parcels);
            drawFloorPlan(planGraphics, parcel.rect, type, entrance, partyWalls);
            planGraphics.dispose();

            g.setColor(type.strokeColor);
            g.setStroke(new BasicStroke(3.5f));
            g.draw(parcel.rect);
        }
    }

    private EnumSet<Edge> findPartyWalls(Parcel parcel, List<Parcel> parcels) {
        EnumSet<Edge> partyWalls = EnumSet.noneOf(Edge.class);
        Rectangle2D.Double rect = parcel.rect;
        for (Edge edge : Edge.values()) {
            if (touchesPerimeter(rect, edge) || touchesAnyRoad(rect, edge)) {
                continue;
            }
            for (Parcel other : parcels) {
                if (other == parcel) {
                    continue;
                }
                if (touchesParcel(rect, edge, other.rect)) {
                    partyWalls.add(edge);
                    break;
                }
            }
        }
        return partyWalls;
    }

    private void drawFloorPlan(Graphics2D g, Rectangle2D.Double rect, BuildingType type, Edge entrance, EnumSet<Edge> partyWalls) {
        g.setColor(FLOOR_TONE);
        g.fill(rect);

        switch (type) {
            case CHURCH:
                drawChurchPlan(g, rect, entrance, partyWalls);
                break;
            case TENEMENT:
                drawTenementPlan(g, rect, entrance, partyWalls);
                break;
            case SHOP:
                drawShopPlan(g, rect, entrance, partyWalls);
                break;
            case PARK:
                drawParkPlan(g, rect);
                break;
            case PRIVATE_HOUSE:
            default:
                drawHousePlan(g, rect, entrance, partyWalls);
                break;
        }
    }

    private void drawHousePlan(Graphics2D g, Rectangle2D.Double rect, Edge entrance, EnumSet<Edge> partyWalls) {
        Graphics2D g2 = (Graphics2D) g.create();
        double doorSpan = orientedSpan(rect, entrance) * 0.26;
        drawOuterWall(g2, rect, entrance, doorSpan, partyWalls);

        double span = orientedSpan(rect, entrance);
        double depth = perpendicularSpan(rect, entrance);

        double faucesDepth = clamp(depth * 0.14, 26, depth * 0.2);
        double atriumDepth = clamp(depth * 0.28, 72, depth * 0.34);
        double tablinumDepth = clamp(depth * 0.1, 32, depth * 0.16);
        double peristyleDepth = clamp(depth * 0.28, 88, depth * 0.36);
        double minimumService = Math.max(48, depth * 0.12);
        double consumed = faucesDepth + atriumDepth + tablinumDepth + peristyleDepth + minimumService;
        if (consumed > depth) {
            double deficit = consumed - depth;
            peristyleDepth = Math.max(peristyleDepth - deficit * 0.55, depth * 0.2);
            atriumDepth = Math.max(atriumDepth - deficit * 0.25, depth * 0.22);
            tablinumDepth = Math.max(tablinumDepth - deficit * 0.1, depth * 0.08);
        }
        double serviceDepth = Math.max(42, depth - (faucesDepth + atriumDepth + tablinumDepth + peristyleDepth));

        double cursorY = 0;

        double faucesWidth = Math.min(span - 18, Math.max(36, span * 0.36));
        double faucesMargin = Math.max(8, (span - faucesWidth) / 2.0);
        Rectangle2D.Double fauces = orientedLocalRect(rect, entrance, faucesMargin, cursorY, faucesWidth, faucesDepth);
        g2.setColor(WALKWAY_TONE);
        g2.fill(fauces);
        cursorY += faucesDepth;

        double atriumWidth = Math.min(span - 20, Math.max(span * 0.72, span * 0.6));
        double atriumMargin = Math.max(10, (span - atriumWidth) / 2.0);
        Rectangle2D.Double atrium = orientedLocalRect(rect, entrance, atriumMargin, cursorY, atriumWidth, atriumDepth);
        g2.setColor(new Color(232, 219, 196));
        g2.fill(atrium);

        Rectangle2D.Double impluvium = insetRect(atrium, atrium.width * 0.35, atrium.height * 0.35);
        g2.setColor(new Color(166, 198, 212));
        g2.fill(impluvium);
        g2.setColor(WALL_TONE);
        g2.setStroke(new BasicStroke(3.2f));
        g2.draw(impluvium);

        double alaWidth = Math.max(24, atriumMargin + atriumWidth * 0.18);
        double alaHeight = atriumDepth * 0.65;
        double alaOffsetY = cursorY + atriumDepth * 0.18;
        Rectangle2D.Double alaLeft = orientedLocalRect(rect, entrance, 0, alaOffsetY, alaWidth, alaHeight);
        Rectangle2D.Double alaRight = orientedLocalRect(rect, entrance, span - alaWidth, alaOffsetY, alaWidth, alaHeight);
        g2.setColor(new Color(221, 206, 178));
        g2.fill(alaLeft);
        g2.fill(alaRight);

        Rectangle2D.Double lararium = orientedLocalRect(rect, entrance, atriumMargin + atriumWidth * 0.35, cursorY + atriumDepth * 0.02, atriumWidth * 0.3, atriumDepth * 0.18);
        g2.setColor(new Color(214, 198, 163));
        g2.fill(lararium);

        Rectangle2D.Double cubiculaFrontLeft = orientedLocalRect(rect, entrance, 0, 0, Math.max(span * 0.22, faucesMargin), cursorY + atriumDepth * 0.3);
        Rectangle2D.Double cubiculaFrontRight = orientedLocalRect(rect, entrance, span - cubiculaFrontLeft.width, 0, cubiculaFrontLeft.width, cursorY + atriumDepth * 0.3);
        g2.setColor(new Color(223, 207, 182));
        g2.fill(cubiculaFrontLeft);
        g2.fill(cubiculaFrontRight);

        g2.setColor(WALL_TONE);
        g2.setStroke(new BasicStroke(3.4f));
        g2.draw(atrium);
        g2.draw(fauces);
        g2.draw(alaLeft);
        g2.draw(alaRight);
        g2.draw(cubiculaFrontLeft);
        g2.draw(cubiculaFrontRight);

        cursorY += atriumDepth;

        double tablinumWidth = Math.min(span - 28, Math.max(span * 0.58, span * 0.48));
        double tablinumMargin = Math.max(12, (span - tablinumWidth) / 2.0);
        Rectangle2D.Double tablinum = orientedLocalRect(rect, entrance, tablinumMargin, cursorY, tablinumWidth, tablinumDepth);
        g2.setColor(new Color(226, 210, 185));
        g2.fill(tablinum);
        g2.setColor(WALL_TONE);
        g2.draw(tablinum);

        cursorY += tablinumDepth;

        double peristyleWidth = Math.min(span - 18, Math.max(span * 0.8, span * 0.64));
        double peristyleMargin = Math.max(9, (span - peristyleWidth) / 2.0);
        Rectangle2D.Double peristyle = orientedLocalRect(rect, entrance, peristyleMargin, cursorY, peristyleWidth, peristyleDepth);
        g2.setColor(WALKWAY_TONE);
        g2.fill(peristyle);
        Rectangle2D.Double viridarium = insetRect(peristyle, peristyle.width * 0.22, peristyle.height * 0.24);
        g2.setColor(new Color(168, 190, 132));
        g2.fill(viridarium);
        drawPeristyleColonnade(g2, peristyle);

        double tricliniumDepth = peristyleDepth * 0.42;
        Rectangle2D.Double triclinium = orientedLocalRect(rect, entrance, 0, cursorY + peristyleDepth * 0.3, peristyleMargin + peristyleWidth * 0.35, tricliniumDepth);
        Rectangle2D.Double oecus = orientedLocalRect(rect, entrance, span - triclinium.width, cursorY + peristyleDepth * 0.28, triclinium.width, tricliniumDepth);
        g2.setColor(new Color(222, 205, 176));
        g2.fill(triclinium);
        g2.fill(oecus);
        g2.setColor(WALL_TONE);
        g2.draw(peristyle);
        g2.draw(triclinium);
        g2.draw(oecus);

        cursorY += peristyleDepth;

        Rectangle2D.Double serviceRange = orientedLocalRect(rect, entrance, 0, cursorY, span, serviceDepth);
        g2.setColor(new Color(214, 198, 163));
        g2.fill(serviceRange);

        double kitchenWidth = Math.max(span * 0.32, span * 0.28);
        Rectangle2D.Double kitchen = orientedLocalRect(rect, entrance, 0, cursorY, kitchenWidth, serviceDepth * 0.72);
        Rectangle2D.Double slaveQuarters = orientedLocalRect(rect, entrance, kitchenWidth + 12, cursorY, Math.max(span * 0.3, span * 0.24), serviceDepth);
        double storageWidth = Math.max(span * 0.28, span * 0.22);
        Rectangle2D.Double storeroom = orientedLocalRect(rect, entrance, span - storageWidth, cursorY, storageWidth, serviceDepth * 0.8);
        g2.setColor(new Color(209, 191, 160));
        g2.fill(kitchen);
        g2.setColor(new Color(221, 206, 180));
        g2.fill(slaveQuarters);
        g2.setColor(new Color(208, 193, 168));
        g2.fill(storeroom);

        g2.setColor(WALL_TONE);
        g2.setStroke(new BasicStroke(3.2f));
        g2.draw(kitchen);
        g2.draw(slaveQuarters);
        g2.draw(storeroom);
        g2.draw(serviceRange);

        Rectangle2D.Double hearth = orientedLocalRect(rect, entrance, kitchenWidth * 0.25, cursorY + serviceDepth * 0.2, kitchenWidth * 0.25, serviceDepth * 0.32);
        g2.setColor(new Color(196, 92, 64));
        g2.fill(hearth);

        g2.dispose();
    }

    private void drawTenementPlan(Graphics2D g, Rectangle2D.Double rect, Edge entrance, EnumSet<Edge> partyWalls) {
        Graphics2D g2 = (Graphics2D) g.create();
        double doorSpan = orientedSpan(rect, entrance) * 0.22;
        drawOuterWall(g2, rect, entrance, doorSpan, partyWalls);

        double span = orientedSpan(rect, entrance);
        double depth = perpendicularSpan(rect, entrance);

        double porticoDepth = clamp(depth * 0.12, 20, depth * 0.18);
        double frontBlockDepth = clamp(depth * 0.18, 42, depth * 0.26);
        double rearBlockDepth = clamp(depth * 0.24, 62, depth * 0.32);
        double serviceYardDepth = clamp(depth * 0.12, 38, depth * 0.18);
        double reserved = porticoDepth + frontBlockDepth + rearBlockDepth + serviceYardDepth;
        double courtyardDepth = Math.max(56, depth - reserved);
        if (courtyardDepth > depth * 0.3) {
            double extra = courtyardDepth - depth * 0.3;
            courtyardDepth -= extra;
            rearBlockDepth += extra * 0.4;
            serviceYardDepth += extra * 0.2;
        }

        double cursorY = 0;

        Rectangle2D.Double portico = orientedLocalRect(rect, entrance, 0, cursorY, span, porticoDepth);
        g2.setColor(WALKWAY_TONE);
        g2.fill(portico);
        cursorY += porticoDepth;

        Rectangle2D.Double frontShops = orientedLocalRect(rect, entrance, 0, cursorY, span, frontBlockDepth);
        g2.setColor(new Color(221, 205, 178));
        g2.fill(frontShops);
        drawStripSubdivisions(g2, frontShops, true, 3 + random.nextInt(2));
        cursorY += frontBlockDepth;

        double courtyardWidth = Math.min(span * 0.54, span - 90);
        double courtyardMargin = Math.max(20, (span - courtyardWidth) / 2.0);
        Rectangle2D.Double lightwell = orientedLocalRect(rect, entrance, courtyardMargin, cursorY, courtyardWidth, courtyardDepth);
        g2.setColor(new Color(224, 210, 184));
        g2.fill(lightwell);

        Rectangle2D.Double cistern = insetRect(lightwell, lightwell.width * 0.4, lightwell.height * 0.4);
        g2.setColor(new Color(182, 204, 214));
        g2.fill(cistern);
        g2.setColor(WALL_TONE);
        g2.setStroke(new BasicStroke(3.1f));
        g2.draw(cistern);

        Rectangle2D.Double leftWalk = orientedLocalRect(rect, entrance, 0, cursorY, courtyardMargin, courtyardDepth);
        Rectangle2D.Double rightWalk = orientedLocalRect(rect, entrance, span - courtyardMargin, cursorY, courtyardMargin, courtyardDepth);
        g2.setColor(WALKWAY_TONE);
        g2.fill(leftWalk);
        g2.fill(rightWalk);

        Rectangle2D.Double stairCoreFront = orientedLocalRect(rect, entrance, courtyardMargin - Math.max(12, span * 0.05), cursorY - porticoDepth * 0.4, Math.max(12, span * 0.05), porticoDepth * 0.9);
        Rectangle2D.Double stairCoreRear = orientedLocalRect(rect, entrance, span - courtyardMargin, cursorY + courtyardDepth - porticoDepth * 0.5, Math.max(12, span * 0.05), porticoDepth);
        g2.setColor(new Color(205, 188, 160));
        g2.fill(stairCoreFront);
        g2.fill(stairCoreRear);

        g2.setColor(WALL_TONE);
        g2.draw(leftWalk);
        g2.draw(rightWalk);
        g2.draw(lightwell);

        cursorY += courtyardDepth;

        Rectangle2D.Double rearBlock = orientedLocalRect(rect, entrance, 0, cursorY, span, rearBlockDepth);
        g2.setColor(new Color(222, 206, 179));
        g2.fill(rearBlock);
        drawStripSubdivisions(g2, rearBlock, true, 4 + random.nextInt(2));

        Rectangle2D.Double stairHall = orientedLocalRect(rect, entrance, span * 0.36, cursorY, span * 0.28, rearBlockDepth);
        g2.setColor(WALKWAY_TONE);
        g2.fill(stairHall);
        g2.setColor(WALL_TONE);
        g2.draw(stairHall);

        cursorY += rearBlockDepth;

        Rectangle2D.Double serviceCourt = orientedLocalRect(rect, entrance, 0, cursorY, span, serviceYardDepth);
        g2.setColor(new Color(210, 196, 168));
        g2.fill(serviceCourt);

        Rectangle2D.Double latrine = orientedLocalRect(rect, entrance, span - Math.max(64, span * 0.18), cursorY + serviceYardDepth * 0.25, Math.max(58, span * 0.16), serviceYardDepth * 0.5);
        g2.setColor(new Color(187, 203, 178));
        g2.fill(latrine);
        g2.setColor(WALL_TONE);
        g2.draw(latrine);

        Rectangle2D.Double cisternYard = orientedLocalRect(rect, entrance, Math.max(40, span * 0.12), cursorY + serviceYardDepth * 0.2, span * 0.22, serviceYardDepth * 0.55);
        g2.setColor(new Color(182, 204, 214));
        g2.fill(cisternYard);
        g2.setColor(WALL_TONE);
        g2.draw(cisternYard);

        g2.setStroke(new BasicStroke(3.3f));
        g2.draw(portico);
        g2.draw(frontShops);
        g2.draw(rearBlock);
        g2.draw(serviceCourt);

        g2.dispose();
    }

    private void drawShopPlan(Graphics2D g, Rectangle2D.Double rect, Edge entrance, EnumSet<Edge> partyWalls) {
        Graphics2D g2 = (Graphics2D) g.create();
        double doorSpan = orientedSpan(rect, entrance) * 0.38;
        drawOuterWall(g2, rect, entrance, doorSpan, partyWalls);

        double depth = perpendicularSpan(rect, entrance);
        double frontDepth = Math.max(24, depth * 0.18);
        double salesDepth = Math.max(48, depth * 0.32);
        double rearDepth = Math.max(32, depth - frontDepth - salesDepth);

        Rectangle2D.Double arcade = createEdgeStrip(rect, entrance, frontDepth);
        g2.setColor(WALKWAY_TONE);
        g2.fill(arcade);

        Rectangle2D.Double salesHall = orientedLocalRect(rect, entrance, 0, frontDepth, orientedSpan(rect, entrance), salesDepth);
        g2.setColor(new Color(224, 208, 180));
        g2.fill(salesHall);

        Rectangle2D.Double counters = orientedLocalRect(rect, entrance, 12, frontDepth + salesDepth * 0.15, orientedSpan(rect, entrance) - 24, salesDepth * 0.18);
        g2.setColor(new Color(204, 188, 160));
        g2.fill(counters);

        Rectangle2D.Double storerooms = createEdgeStrip(rect, opposite(entrance), rearDepth);
        g2.setColor(new Color(207, 195, 166));
        g2.fill(storerooms);

        Rectangle2D.Double offices = orientedLocalRect(rect, entrance, 0, frontDepth + salesDepth, orientedSpan(rect, entrance) * 0.35, rearDepth);
        Rectangle2D.Double workshop = orientedLocalRect(rect, entrance, orientedSpan(rect, entrance) - offices.width, frontDepth + salesDepth, offices.width, rearDepth);
        g2.setColor(new Color(210, 194, 170));
        g2.fill(offices);
        g2.fill(workshop);

        boolean horizontal = entrance == Edge.NORTH || entrance == Edge.SOUTH;
        int stalls = Math.max(3, (int) Math.round((horizontal ? rect.width : rect.height) / 120.0 * 3));
        drawStripSubdivisions(g2, salesHall, horizontal, stalls);

        Rectangle2D.Double servicePassage = createConnector(rect, storerooms, entrance, 0.25);
        g2.setColor(WALKWAY_TONE);
        g2.fill(servicePassage);

        g2.setColor(WALL_TONE);
        g2.setStroke(new BasicStroke(3.2f));
        g2.draw(arcade);
        g2.draw(storerooms);
        g2.draw(offices);
        g2.draw(workshop);
        g2.draw(counters);

        g2.dispose();
    }

    private void drawChurchPlan(Graphics2D g, Rectangle2D.Double rect, Edge entrance, EnumSet<Edge> partyWalls) {
        Graphics2D g2 = (Graphics2D) g.create();
        double doorSpan = orientedSpan(rect, entrance) * 0.3;
        drawOuterWall(g2, rect, entrance, doorSpan, partyWalls);

        Rectangle2D.Double narthex = createEdgeStrip(rect, entrance, perpendicularSpan(rect, entrance) * 0.14);
        g2.setColor(WALKWAY_TONE);
        g2.fill(narthex);

        Rectangle2D.Double nave = insetRect(rect, rect.width * 0.18, rect.height * 0.12);
        g2.setColor(new Color(230, 219, 194));
        g2.fill(nave);

        Rectangle2D.Double aisles = insetRect(nave, nave.width * 0.26, 0);
        g2.setColor(new Color(224, 210, 182));
        g2.fill(aisles);

        Rectangle2D.Double transept = createTransept(nave, entrance, perpendicularSpan(rect, entrance) * 0.24);
        g2.setColor(new Color(226, 214, 188));
        g2.fill(transept);

        Rectangle2D.Double crossing = insetRect(transept, transept.width * 0.25, transept.height * 0.25);
        g2.setColor(new Color(221, 206, 178));
        g2.fill(crossing);

        Rectangle2D.Double apse = createApse(nave, entrance, perpendicularSpan(rect, entrance) * 0.22);
        g2.setColor(new Color(221, 209, 180));
        g2.fill(apse);

        Rectangle2D.Double choir = insetRect(apse, apse.width * 0.18, apse.height * 0.18);
        g2.setColor(new Color(214, 198, 163));
        g2.fill(choir);

        Rectangle2D.Double ambulatory = insetRect(apse, apse.width * 0.06, apse.height * 0.08);
        g2.setColor(new Color(214, 198, 163));
        g2.draw(ambulatory);

        Rectangle2D.Double chapelsNorth = orientedLocalRect(rect, entrance, 0, perpendicularSpan(rect, entrance) * 0.42, rect.width * 0.16, perpendicularSpan(rect, entrance) * 0.26);
        Rectangle2D.Double chapelsSouth = orientedLocalRect(rect, entrance, rect.width - chapelsNorth.width, perpendicularSpan(rect, entrance) * 0.42, chapelsNorth.width, perpendicularSpan(rect, entrance) * 0.26);
        g2.setColor(new Color(209, 194, 170));
        g2.fill(chapelsNorth);
        g2.fill(chapelsSouth);

        drawColonnade(g2, nave, entrance);

        g2.setColor(WALL_TONE);
        g2.setStroke(new BasicStroke(3.4f));
        g2.draw(nave);
        g2.draw(transept);
        g2.draw(apse);
        g2.draw(chapelsNorth);
        g2.draw(chapelsSouth);
        g2.draw(narthex);

        g2.dispose();
    }

    private void drawParkPlan(Graphics2D g, Rectangle2D.Double rect) {
        Graphics2D g2 = (Graphics2D) g.create();
        g2.setColor(new Color(156, 192, 132));
        g2.fill(rect);

        g2.setColor(new Color(120, 90, 60, 180));
        g2.setStroke(new BasicStroke(6f));
        g2.draw(rect);

        g2.setStroke(new BasicStroke(8f));
        Rectangle2D.Double crossPathH = new Rectangle2D.Double(rect.x, rect.getCenterY() - rect.height * 0.05, rect.width, rect.height * 0.1);
        Rectangle2D.Double crossPathV = new Rectangle2D.Double(rect.getCenterX() - rect.width * 0.05, rect.y, rect.width * 0.1, rect.height);
        g2.setColor(new Color(214, 198, 163));
        g2.fill(crossPathH);
        g2.fill(crossPathV);

        g2.setColor(new Color(116, 156, 104));
        for (int i = 0; i < 14; i++) {
            double x = rect.x + rect.width * (0.1 + 0.8 * random.nextDouble());
            double y = rect.y + rect.height * (0.1 + 0.8 * random.nextDouble());
            g2.fill(new Rectangle2D.Double(x, y, 8 + random.nextInt(8), 8 + random.nextInt(8)));
        }

        g2.dispose();
    }

    private void drawOuterWall(Graphics2D g, Rectangle2D.Double rect, Edge entrance, double doorSpan, EnumSet<Edge> partyWalls) {
        g.setColor(WALL_TONE);
        BasicStroke exterior = new BasicStroke(6f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER);
        BasicStroke shared = new BasicStroke(4.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER);
        if (entrance == null) {
            g.setStroke(partyWalls.isEmpty() ? exterior : shared);
            g.draw(rect);
            return;
        }
        double doorCenter;
        switch (entrance) {
            case NORTH:
                doorCenter = rect.getCenterX();
                g.setStroke(partyWalls.contains(Edge.NORTH) ? shared : exterior);
                drawLineWithGap(g, rect.x, rect.y, rect.getMaxX(), rect.y, doorCenter, doorSpan, true);
                g.setStroke(partyWalls.contains(Edge.WEST) ? shared : exterior);
                g.draw(new Line2D.Double(rect.x, rect.y, rect.x, rect.getMaxY()));
                g.setStroke(partyWalls.contains(Edge.EAST) ? shared : exterior);
                g.draw(new Line2D.Double(rect.getMaxX(), rect.y, rect.getMaxX(), rect.getMaxY()));
                g.setStroke(partyWalls.contains(Edge.SOUTH) ? shared : exterior);
                g.draw(new Line2D.Double(rect.x, rect.getMaxY(), rect.getMaxX(), rect.getMaxY()));
                break;
            case SOUTH:
                doorCenter = rect.getCenterX();
                g.setStroke(partyWalls.contains(Edge.NORTH) ? shared : exterior);
                g.draw(new Line2D.Double(rect.x, rect.y, rect.getMaxX(), rect.y));
                g.setStroke(partyWalls.contains(Edge.WEST) ? shared : exterior);
                g.draw(new Line2D.Double(rect.x, rect.y, rect.x, rect.getMaxY()));
                g.setStroke(partyWalls.contains(Edge.EAST) ? shared : exterior);
                g.draw(new Line2D.Double(rect.getMaxX(), rect.y, rect.getMaxX(), rect.getMaxY()));
                g.setStroke(partyWalls.contains(Edge.SOUTH) ? shared : exterior);
                drawLineWithGap(g, rect.x, rect.getMaxY(), rect.getMaxX(), rect.getMaxY(), doorCenter, doorSpan, true);
                break;
            case EAST:
                doorCenter = rect.getCenterY();
                g.setStroke(partyWalls.contains(Edge.NORTH) ? shared : exterior);
                g.draw(new Line2D.Double(rect.x, rect.y, rect.getMaxX(), rect.y));
                g.setStroke(partyWalls.contains(Edge.EAST) ? shared : exterior);
                drawLineWithGap(g, rect.getMaxX(), rect.y, rect.getMaxX(), rect.getMaxY(), doorCenter, doorSpan, false);
                g.setStroke(partyWalls.contains(Edge.SOUTH) ? shared : exterior);
                g.draw(new Line2D.Double(rect.x, rect.getMaxY(), rect.getMaxX(), rect.getMaxY()));
                g.setStroke(partyWalls.contains(Edge.WEST) ? shared : exterior);
                g.draw(new Line2D.Double(rect.x, rect.y, rect.x, rect.getMaxY()));
                break;
            case WEST:
            default:
                doorCenter = rect.getCenterY();
                g.setStroke(partyWalls.contains(Edge.WEST) ? shared : exterior);
                drawLineWithGap(g, rect.x, rect.y, rect.x, rect.getMaxY(), doorCenter, doorSpan, false);
                g.setStroke(partyWalls.contains(Edge.EAST) ? shared : exterior);
                g.draw(new Line2D.Double(rect.getMaxX(), rect.y, rect.getMaxX(), rect.getMaxY()));
                g.setStroke(partyWalls.contains(Edge.NORTH) ? shared : exterior);
                g.draw(new Line2D.Double(rect.x, rect.y, rect.getMaxX(), rect.y));
                g.setStroke(partyWalls.contains(Edge.SOUTH) ? shared : exterior);
                g.draw(new Line2D.Double(rect.x, rect.getMaxY(), rect.getMaxX(), rect.getMaxY()));
                break;
        }
    }

    private Rectangle2D.Double insetRect(Rectangle2D.Double rect, double insetX, double insetY) {
        return new Rectangle2D.Double(rect.x + insetX, rect.y + insetY, rect.width - 2 * insetX, rect.height - 2 * insetY);
    }

    private Rectangle2D.Double orientedLocalRect(Rectangle2D.Double rect, Edge entrance, double localX, double localY, double width, double height) {
        width = Math.max(0, width);
        height = Math.max(0, height);
        switch (entrance) {
            case NORTH:
                return new Rectangle2D.Double(
                        rect.getMaxX() - (localX + width),
                        rect.y + localY,
                        width,
                        height
                );
            case EAST:
                return new Rectangle2D.Double(
                        rect.getMaxX() - (localY + height),
                        rect.getMaxY() - (localX + width),
                        height,
                        width
                );
            case WEST:
                return new Rectangle2D.Double(
                        rect.x + localY,
                        rect.y + localX,
                        height,
                        width
                );
            case SOUTH:
            default:
                return new Rectangle2D.Double(
                        rect.x + localX,
                        rect.getMaxY() - (localY + height),
                        width,
                        height
                );
        }
    }

    private Rectangle2D.Double createTransept(Rectangle2D.Double nave, Edge entrance, double thickness) {
        double span = orientedSpan(nave, entrance);
        double depth = perpendicularSpan(nave, entrance);
        double clampedThickness = Math.min(thickness, depth);
        double start = Math.max(0, depth * 0.52 - clampedThickness / 2.0);
        if (start + clampedThickness > depth) {
            start = depth - clampedThickness;
        }
        return orientedLocalRect(nave, entrance, 0, start, span, clampedThickness);
    }

    private Rectangle2D.Double createApse(Rectangle2D.Double nave, Edge entrance, double depth) {
        double span = orientedSpan(nave, entrance);
        double margin = Math.max(12, span * 0.18);
        double width = Math.max(span - margin * 2, span * 0.45);
        double start = Math.max(0, perpendicularSpan(nave, entrance) - depth);
        return orientedLocalRect(nave, entrance, (span - width) / 2.0, start, width, Math.min(depth, perpendicularSpan(nave, entrance)));
    }

    private Rectangle2D.Double createEdgeStrip(Rectangle2D.Double rect, Edge edge, double depth) {
        switch (edge) {
            case NORTH:
                return new Rectangle2D.Double(rect.x, rect.y, rect.width, depth);
            case SOUTH:
                return new Rectangle2D.Double(rect.x, rect.getMaxY() - depth, rect.width, depth);
            case EAST:
                return new Rectangle2D.Double(rect.getMaxX() - depth, rect.y, depth, rect.height);
            case WEST:
            default:
                return new Rectangle2D.Double(rect.x, rect.y, depth, rect.height);
        }
    }

    private double clamp(double value, double min, double max) {
        if (max < min) {
            return min;
        }
        return Math.max(min, Math.min(max, value));
    }

    private Rectangle2D.Double createConnector(Rectangle2D.Double outer, Rectangle2D.Double inner, Edge edge, double ratio) {
        double width;
        double height;
        switch (edge) {
            case NORTH:
                width = inner.width * ratio;
                height = Math.max(inner.y - outer.y, 12);
                return new Rectangle2D.Double(inner.getCenterX() - width / 2.0, inner.y - height, width, height);
            case SOUTH:
                width = inner.width * ratio;
                height = Math.max(outer.getMaxY() - inner.getMaxY(), 12);
                return new Rectangle2D.Double(inner.getCenterX() - width / 2.0, inner.getMaxY(), width, height);
            case EAST:
                width = Math.max(outer.getMaxX() - inner.getMaxX(), 12);
                height = inner.height * ratio;
                return new Rectangle2D.Double(inner.getMaxX(), inner.getCenterY() - height / 2.0, width, height);
            case WEST:
            default:
                width = Math.max(inner.x - outer.x, 12);
                height = inner.height * ratio;
                return new Rectangle2D.Double(inner.x - width, inner.getCenterY() - height / 2.0, width, height);
        }
    }

    private Rectangle2D.Double createWing(Rectangle2D.Double outer, Rectangle2D.Double inner, Edge side) {
        switch (side) {
            case NORTH:
                return new Rectangle2D.Double(inner.x, outer.y, inner.width, Math.max(0, inner.y - outer.y));
            case SOUTH:
                return new Rectangle2D.Double(inner.x, inner.getMaxY(), inner.width, Math.max(0, outer.getMaxY() - inner.getMaxY()));
            case EAST:
                return new Rectangle2D.Double(inner.getMaxX(), inner.y, Math.max(0, outer.getMaxX() - inner.getMaxX()), inner.height);
            case WEST:
            default:
                return new Rectangle2D.Double(outer.x, inner.y, Math.max(0, inner.x - outer.x), inner.height);
        }
    }

    private Rectangle2D.Double middleBand(Rectangle2D.Double outer, Rectangle2D.Double frontStrip, Rectangle2D.Double rearStrip, Edge entrance) {
        if (entrance == Edge.NORTH || entrance == Edge.SOUTH) {
            double y = frontStrip.y + frontStrip.height;
            double height = outer.height - frontStrip.height - rearStrip.height;
            return new Rectangle2D.Double(outer.x, y, outer.width, Math.max(0, height));
        } else {
            double x = frontStrip.x + frontStrip.width;
            double width = outer.width - frontStrip.width - rearStrip.width;
            return new Rectangle2D.Double(x, outer.y, Math.max(0, width), outer.height);
        }
    }

    private void drawWingRooms(Graphics2D g, Rectangle2D.Double wing, boolean vertical, int rooms) {
        if (wing.width <= 0 || wing.height <= 0 || rooms <= 0) {
            return;
        }
        g.setColor(new Color(221, 205, 176));
        g.fill(wing);

        g.setColor(WALL_TONE);
        g.setStroke(new BasicStroke(3f));
        if (rooms <= 1) {
            return;
        }
        if (vertical) {
            double step = wing.height / rooms;
            for (int i = 1; i < rooms; i++) {
                double y = wing.y + i * step;
                g.draw(new Line2D.Double(wing.x, y, wing.getMaxX(), y));
            }
        } else {
            double step = wing.width / rooms;
            for (int i = 1; i < rooms; i++) {
                double x = wing.x + i * step;
                g.draw(new Line2D.Double(x, wing.y, x, wing.getMaxY()));
            }
        }
    }

    private void drawStripSubdivisions(Graphics2D g, Rectangle2D.Double area, boolean horizontal, int partitions) {
        if (area.width <= 0 || area.height <= 0 || partitions <= 0) {
            return;
        }
        g.setColor(new Color(221, 206, 179));
        g.fill(area);

        g.setColor(WALL_TONE);
        g.setStroke(new BasicStroke(3.2f));
        if (partitions <= 1) {
            return;
        }
        if (horizontal) {
            double step = area.width / partitions;
            for (int i = 1; i < partitions; i++) {
                double x = area.x + i * step;
                g.draw(new Line2D.Double(x, area.y, x, area.getMaxY()));
            }
        } else {
            double step = area.height / partitions;
            for (int i = 1; i < partitions; i++) {
                double y = area.y + i * step;
                g.draw(new Line2D.Double(area.x, y, area.getMaxX(), y));
            }
        }
    }

    private void drawRectOutlineWithDoor(Graphics2D g, Rectangle2D.Double rect, Edge doorwaySide, Rectangle2D.Double connector) {
        g.setColor(WALL_TONE);
        g.setStroke(new BasicStroke(3.4f));
        if (doorwaySide == null) {
            g.draw(rect);
            return;
        }
        double gapCenter;
        double gapWidth;
        switch (doorwaySide) {
            case NORTH:
                gapCenter = connector != null ? connector.getCenterX() : rect.getCenterX();
                gapWidth = connector != null ? connector.width : rect.width * 0.25;
                drawLineWithGap(g, rect.x, rect.y, rect.getMaxX(), rect.y, gapCenter, gapWidth, true);
                g.draw(new Line2D.Double(rect.x, rect.y, rect.x, rect.getMaxY()));
                g.draw(new Line2D.Double(rect.getMaxX(), rect.y, rect.getMaxX(), rect.getMaxY()));
                g.draw(new Line2D.Double(rect.x, rect.getMaxY(), rect.getMaxX(), rect.getMaxY()));
                break;
            case SOUTH:
                gapCenter = connector != null ? connector.getCenterX() : rect.getCenterX();
                gapWidth = connector != null ? connector.width : rect.width * 0.25;
                g.draw(new Line2D.Double(rect.x, rect.y, rect.getMaxX(), rect.y));
                g.draw(new Line2D.Double(rect.x, rect.y, rect.x, rect.getMaxY()));
                g.draw(new Line2D.Double(rect.getMaxX(), rect.y, rect.getMaxX(), rect.getMaxY()));
                drawLineWithGap(g, rect.x, rect.getMaxY(), rect.getMaxX(), rect.getMaxY(), gapCenter, gapWidth, true);
                break;
            case EAST:
                gapCenter = connector != null ? connector.getCenterY() : rect.getCenterY();
                gapWidth = connector != null ? connector.height : rect.height * 0.25;
                g.draw(new Line2D.Double(rect.x, rect.y, rect.getMaxX(), rect.y));
                drawLineWithGap(g, rect.getMaxX(), rect.y, rect.getMaxX(), rect.getMaxY(), gapCenter, gapWidth, false);
                g.draw(new Line2D.Double(rect.x, rect.getMaxY(), rect.getMaxX(), rect.getMaxY()));
                g.draw(new Line2D.Double(rect.x, rect.y, rect.x, rect.getMaxY()));
                break;
            case WEST:
            default:
                gapCenter = connector != null ? connector.getCenterY() : rect.getCenterY();
                gapWidth = connector != null ? connector.height : rect.height * 0.25;
                drawLineWithGap(g, rect.x, rect.y, rect.x, rect.getMaxY(), gapCenter, gapWidth, false);
                g.draw(new Line2D.Double(rect.getMaxX(), rect.y, rect.getMaxX(), rect.getMaxY()));
                g.draw(new Line2D.Double(rect.x, rect.y, rect.getMaxX(), rect.y));
                g.draw(new Line2D.Double(rect.x, rect.getMaxY(), rect.getMaxX(), rect.getMaxY()));
                break;
        }
    }

    private void drawEdgeWall(Graphics2D g, Rectangle2D.Double rect, Edge side, Rectangle2D.Double connector, double reliefRatio) {
        g.setColor(WALL_TONE);
        g.setStroke(new BasicStroke(3.0f));
        if (connector == null) {
            switch (side) {
                case NORTH:
                    g.draw(new Line2D.Double(rect.x, rect.y, rect.getMaxX(), rect.y));
                    break;
                case SOUTH:
                    g.draw(new Line2D.Double(rect.x, rect.getMaxY(), rect.getMaxX(), rect.getMaxY()));
                    break;
                case EAST:
                    g.draw(new Line2D.Double(rect.getMaxX(), rect.y, rect.getMaxX(), rect.getMaxY()));
                    break;
                case WEST:
                default:
                    g.draw(new Line2D.Double(rect.x, rect.y, rect.x, rect.getMaxY()));
                    break;
            }
            return;
        }
        double gapCenter;
        double gapWidth;
        switch (side) {
            case NORTH:
                gapCenter = connector.getCenterX();
                gapWidth = connector.width * (1 - reliefRatio);
                drawLineWithGap(g, rect.x, rect.y, rect.getMaxX(), rect.y, gapCenter, gapWidth, true);
                break;
            case SOUTH:
                gapCenter = connector.getCenterX();
                gapWidth = connector.width * (1 - reliefRatio);
                drawLineWithGap(g, rect.x, rect.getMaxY(), rect.getMaxX(), rect.getMaxY(), gapCenter, gapWidth, true);
                break;
            case EAST:
                gapCenter = connector.getCenterY();
                gapWidth = connector.height * (1 - reliefRatio);
                drawLineWithGap(g, rect.getMaxX(), rect.y, rect.getMaxX(), rect.getMaxY(), gapCenter, gapWidth, false);
                break;
            case WEST:
            default:
                gapCenter = connector.getCenterY();
                gapWidth = connector.height * (1 - reliefRatio);
                drawLineWithGap(g, rect.x, rect.y, rect.x, rect.getMaxY(), gapCenter, gapWidth, false);
                break;
        }
    }

    private void drawLineWithGap(Graphics2D g, double x1, double y1, double x2, double y2, double gapCenter, double gapSpan, boolean horizontal) {
        double half = gapSpan / 2.0;
        if (horizontal) {
            double start = Math.min(gapCenter - half, gapCenter + half);
            double end = Math.max(gapCenter - half, gapCenter + half);
            double minX = Math.min(x1, x2);
            double maxX = Math.max(x1, x2);
            double gapStart = Math.max(minX, start);
            double gapEnd = Math.min(maxX, end);
            if (gapStart > minX) {
                g.draw(new Line2D.Double(minX, y1, gapStart, y1));
            }
            if (gapEnd < maxX) {
                g.draw(new Line2D.Double(gapEnd, y1, maxX, y1));
            }
        } else {
            double start = Math.min(gapCenter - half, gapCenter + half);
            double end = Math.max(gapCenter - half, gapCenter + half);
            double minY = Math.min(y1, y2);
            double maxY = Math.max(y1, y2);
            double gapStart = Math.max(minY, start);
            double gapEnd = Math.min(maxY, end);
            if (gapStart > minY) {
                g.draw(new Line2D.Double(x1, minY, x1, gapStart));
            }
            if (gapEnd < maxY) {
                g.draw(new Line2D.Double(x1, gapEnd, x1, maxY));
            }
        }
    }

    private void drawColonnade(Graphics2D g, Rectangle2D.Double nave, Edge entrance) {
        g.setColor(new Color(155, 130, 98));
        double spacing = (entrance == Edge.NORTH || entrance == Edge.SOUTH) ? nave.width / 6.0 : nave.height / 6.0;
        double radius = spacing * 0.18;
        int columns = 6;
        for (int i = 1; i < columns; i++) {
            if (entrance == Edge.NORTH || entrance == Edge.SOUTH) {
                double x = nave.x + i * spacing;
                g.fill(new Rectangle2D.Double(x - radius, nave.y + nave.height * 0.18, radius * 2, radius * 2));
                g.fill(new Rectangle2D.Double(x - radius, nave.getMaxY() - nave.height * 0.18 - radius * 2, radius * 2, radius * 2));
            } else {
                double y = nave.y + i * spacing;
                g.fill(new Rectangle2D.Double(nave.x + nave.width * 0.18, y - radius, radius * 2, radius * 2));
                g.fill(new Rectangle2D.Double(nave.getMaxX() - nave.width * 0.18 - radius * 2, y - radius, radius * 2, radius * 2));
            }
        }
    }

    private void drawPeristyleColonnade(Graphics2D g, Rectangle2D.Double peristyle) {
        g.setColor(new Color(155, 130, 98));
        int columns = 6;
        double spacingX = peristyle.width / (columns + 1);
        double spacingY = peristyle.height / (columns + 1);
        double size = Math.min(spacingX, spacingY) * 0.35;
        for (int i = 1; i <= columns; i++) {
            double x = peristyle.x + i * spacingX;
            double y = peristyle.y + peristyle.height * 0.18;
            g.fill(new Rectangle2D.Double(x - size / 2.0, y - size / 2.0, size, size));
            g.fill(new Rectangle2D.Double(x - size / 2.0, peristyle.getMaxY() - peristyle.height * 0.18 - size / 2.0, size, size));
        }
        for (int j = 1; j <= columns; j++) {
            double y = peristyle.y + j * spacingY;
            double x = peristyle.x + peristyle.width * 0.18;
            g.fill(new Rectangle2D.Double(x - size / 2.0, y - size / 2.0, size, size));
            g.fill(new Rectangle2D.Double(peristyle.getMaxX() - peristyle.width * 0.18 - size / 2.0, y - size / 2.0, size, size));
        }
    }

    private Edge findEntranceSide(Parcel parcel) {
        Rectangle2D.Double rect = parcel.rect;
        Edge bestEdge = null;
        double bestScore = -1;
        for (Edge edge : Edge.values()) {
            double score = 0;
            if (touchesPerimeter(rect, edge)) {
                score += edgeLength(rect, edge) * 2.0;
            }
            score += roadContactScore(rect, edge);
            if (score > bestScore) {
                bestScore = score;
                bestEdge = edge;
            }
        }
        if (bestEdge == null) {
            bestEdge = Edge.SOUTH;
        }
        return bestEdge;
    }

    private double roadContactScore(Rectangle2D.Double rect, Edge edge) {
        if (currentRoads == null) {
            return 0;
        }
        double score = 0;
        for (Road road : currentRoads) {
            if (touchesRoad(rect, edge, road.rect)) {
                score += overlapLength(rect, edge, road.rect) * 1.5;
            }
        }
        return score;
    }

    private boolean touchesAnyRoad(Rectangle2D.Double rect, Edge edge) {
        if (currentRoads == null) {
            return false;
        }
        for (Road road : currentRoads) {
            if (touchesRoad(rect, edge, road.rect)) {
                return true;
            }
        }
        return false;
    }

    private boolean touchesPerimeter(Rectangle2D.Double rect, Edge edge) {
        if (buildableArea == null) {
            return false;
        }
        double epsilon = 0.5;
        switch (edge) {
            case NORTH:
                return Math.abs(rect.y - buildableArea.y) < epsilon;
            case SOUTH:
                return Math.abs(rect.getMaxY() - buildableArea.getMaxY()) < epsilon;
            case EAST:
                return Math.abs(rect.getMaxX() - buildableArea.getMaxX()) < epsilon;
            case WEST:
            default:
                return Math.abs(rect.x - buildableArea.x) < epsilon;
        }
    }

    private boolean touchesRoad(Rectangle2D.Double rect, Edge edge, Rectangle2D.Double road) {
        double epsilon = 0.5;
        switch (edge) {
            case NORTH:
                if (Math.abs(rect.y - road.getMaxY()) < epsilon) {
                    return segmentsOverlap(rect.x, rect.getMaxX(), road.x, road.getMaxX());
                }
                break;
            case SOUTH:
                if (Math.abs(rect.getMaxY() - road.y) < epsilon) {
                    return segmentsOverlap(rect.x, rect.getMaxX(), road.x, road.getMaxX());
                }
                break;
            case EAST:
                if (Math.abs(rect.getMaxX() - road.x) < epsilon) {
                    return segmentsOverlap(rect.y, rect.getMaxY(), road.y, road.getMaxY());
                }
                break;
            case WEST:
            default:
                if (Math.abs(rect.x - road.getMaxX()) < epsilon) {
                    return segmentsOverlap(rect.y, rect.getMaxY(), road.y, road.getMaxY());
                }
                break;
        }
        return false;
    }

    private boolean touchesParcel(Rectangle2D.Double rect, Edge edge, Rectangle2D.Double other) {
        double epsilon = 0.5;
        switch (edge) {
            case NORTH:
                if (Math.abs(rect.y - other.getMaxY()) < epsilon) {
                    return segmentsOverlap(rect.x, rect.getMaxX(), other.x, other.getMaxX());
                }
                break;
            case SOUTH:
                if (Math.abs(rect.getMaxY() - other.y) < epsilon) {
                    return segmentsOverlap(rect.x, rect.getMaxX(), other.x, other.getMaxX());
                }
                break;
            case EAST:
                if (Math.abs(rect.getMaxX() - other.x) < epsilon) {
                    return segmentsOverlap(rect.y, rect.getMaxY(), other.y, other.getMaxY());
                }
                break;
            case WEST:
            default:
                if (Math.abs(rect.x - other.getMaxX()) < epsilon) {
                    return segmentsOverlap(rect.y, rect.getMaxY(), other.y, other.getMaxY());
                }
                break;
        }
        return false;
    }

    private boolean segmentsOverlap(double a1, double a2, double b1, double b2) {
        double minA = Math.min(a1, a2);
        double maxA = Math.max(a1, a2);
        double minB = Math.min(b1, b2);
        double maxB = Math.max(b1, b2);
        return maxA > minB && maxB > minA;
    }

    private double overlapLength(Rectangle2D.Double rect, Edge edge, Rectangle2D.Double road) {
        if (edge == Edge.NORTH || edge == Edge.SOUTH) {
            double start = Math.max(rect.x, road.x);
            double end = Math.min(rect.getMaxX(), road.getMaxX());
            return Math.max(0, end - start);
        } else {
            double start = Math.max(rect.y, road.y);
            double end = Math.min(rect.getMaxY(), road.getMaxY());
            return Math.max(0, end - start);
        }
    }

    private double edgeLength(Rectangle2D.Double rect, Edge edge) {
        return (edge == Edge.NORTH || edge == Edge.SOUTH) ? rect.width : rect.height;
    }

    private double orientedSpan(Rectangle2D.Double rect, Edge entrance) {
        return (entrance == Edge.NORTH || entrance == Edge.SOUTH) ? rect.width : rect.height;
    }

    private double perpendicularSpan(Rectangle2D.Double rect, Edge entrance) {
        return (entrance == Edge.NORTH || entrance == Edge.SOUTH) ? rect.height : rect.width;
    }

    private Edge rotateClockwise(Edge edge) {
        switch (edge) {
            case NORTH:
                return Edge.EAST;
            case EAST:
                return Edge.SOUTH;
            case SOUTH:
                return Edge.WEST;
            case WEST:
            default:
                return Edge.NORTH;
        }
    }

    private Edge rotateCounterClockwise(Edge edge) {
        switch (edge) {
            case NORTH:
                return Edge.WEST;
            case WEST:
                return Edge.SOUTH;
            case SOUTH:
                return Edge.EAST;
            case EAST:
            default:
                return Edge.NORTH;
        }
    }

    private Edge opposite(Edge edge) {
        switch (edge) {
            case NORTH:
                return Edge.SOUTH;
            case SOUTH:
                return Edge.NORTH;
            case EAST:
                return Edge.WEST;
            case WEST:
            default:
                return Edge.EAST;
        }
    }

    private void annotateParcels(Graphics2D g, List<Parcel> parcels) {
        g.setFont(LABEL_FONT);
        for (Parcel parcel : parcels) {
            if (parcel.type == null) {
                continue;
            }
            String label = parcel.type.label;
            float x = (float) (parcel.rect.getCenterX() - g.getFontMetrics().stringWidth(label) / 2.0);
            float y = (float) (parcel.rect.getCenterY() + g.getFontMetrics().getAscent() / 2.5);
            g.setColor(new Color(30, 20, 10, 140));
            g.drawString(label, x, y);
        }
    }

    private double randomRange(double min, double max) {
        return min + random.nextDouble() * (max - min);
    }

    private static class Parcel {
        final Rectangle2D.Double rect;
        BuildingType type = BuildingType.UNASSIGNED;

        Parcel(Rectangle2D.Double rect) {
            this.rect = rect;
        }

        double area() {
            return rect.width * rect.height;
        }
    }

    private static class Road {
        final Rectangle2D.Double rect;
        final double width;

        Road(Rectangle2D.Double rect, double width) {
            this.rect = rect;
            this.width = width;
        }
    }

    private enum Edge {
        NORTH,
        EAST,
        SOUTH,
        WEST
    }

    private enum BuildingType {
        PRIVATE_HOUSE(new Color(196, 136, 96), new Color(120, 70, 50), "DOMUS"),
        TENEMENT(new Color(180, 120, 88), new Color(102, 60, 40), "INSULAE"),
        CHURCH(new Color(210, 188, 150), new Color(120, 80, 60), "BASILICA"),
        SHOP(new Color(200, 160, 110), new Color(130, 90, 60), "EMPORIA"),
        PARK(new Color(150, 185, 120), new Color(80, 110, 70), "HORTUS"),
        UNASSIGNED(new Color(0, 0, 0, 0), new Color(0, 0, 0, 0), "");

        final Color fillColor;
        final Color strokeColor;
        final String label;

        BuildingType(Color fillColor, Color strokeColor, String label) {
            this.fillColor = fillColor;
            this.strokeColor = strokeColor;
            this.label = label;
        }
    }
}