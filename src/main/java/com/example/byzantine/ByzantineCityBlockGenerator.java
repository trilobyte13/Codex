package com.example.byzantine;

import javax.imageio.ImageIO;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.GradientPaint;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.TexturePaint;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Line2D;
import java.awt.geom.Rectangle2D;
import java.awt.geom.RoundRectangle2D;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Deque;
import java.util.EnumSet;
import java.util.List;
import java.util.Random;

/**
 * Generates a randomly decorated Byzantine city block floor plan.
 *
 * <p>The generator combines late Roman and medieval inspired building layouts by
 * carving streets and alleys into a block and allocating parcels for different
 * building archetypes such as private houses, insulae (tenements), churches,
 * shops and green spaces. The output is written to {@code byzantine_city_block.png}.</p>
 */
public class ByzantineCityBlockGenerator {

    private static final double SCALE = 2.35;
    private static final int IMAGE_WIDTH = 2000;
    private static final int IMAGE_HEIGHT = 2300;
    private static final int MARGIN = (int) Math.round(40 * SCALE);
    private static final int PERIMETER_ROAD = (int) Math.round(70 * SCALE);
    private static final int MIN_PARCEL_SIZE = (int) Math.round(90 * SCALE);
    private static final int ROAD_WIDTH_MIN = (int) Math.round(12 * SCALE);
    private static final int ROAD_WIDTH_MAX = (int) Math.round(26 * SCALE);
    private static final Color BACKGROUND_COLOR = new Color(238, 232, 213);
    private static final Color ROAD_COLOR = new Color(176, 159, 132);
    private static final Color ALLEY_COLOR = new Color(205, 186, 154);
    private static final Font LABEL_FONT = new Font("Serif", Font.BOLD, (int) Math.round(14 * SCALE));
    private static final Color FLOOR_TONE = new Color(220, 209, 186);
    private static final Color WALL_TONE = new Color(109, 78, 55);
    private static final Color WALKWAY_TONE = new Color(214, 198, 163);

    private final Random random;
    private Rectangle2D.Double buildableArea;
    private List<Road> currentRoads;

    private ByzantineCityBlockGenerator(long seed) {
        this.random = new Random(seed);
    }

    public static void main(String[] args) throws IOException {
        long seed = System.currentTimeMillis();
        ByzantineCityBlockGenerator generator = new ByzantineCityBlockGenerator(seed);
        BufferedImage image = generator.createPlan();
        ImageIO.write(image, "png", new File("byzantine_city_block.png"));
        System.out.println("Generated byzantine_city_block.png with seed " + seed);
    }

    private BufferedImage createPlan() {
        BufferedImage image = new BufferedImage(IMAGE_WIDTH, IMAGE_HEIGHT, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g = image.createGraphics();
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        g.setColor(BACKGROUND_COLOR);
        g.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);

        LegendLayout legendLayout = measureLegend(g);
        double blockWidth = IMAGE_WIDTH - 2 * MARGIN;
        if (blockWidth < MIN_PARCEL_SIZE * 2) {
            blockWidth = MIN_PARCEL_SIZE * 2;
        }
        double availableHeight = IMAGE_HEIGHT - 2 * MARGIN;
        double blockHeight = availableHeight;
        double legendSpacing = 0;
        if (legendLayout != null) {
            double minSpacing = Math.round(18 * SCALE);
            double desiredSpacing = Math.max(Math.round(24 * SCALE), Math.round(MARGIN * 0.6));
            legendSpacing = Math.max(desiredSpacing, minSpacing);
            blockHeight = availableHeight - legendLayout.height - legendSpacing;
            if (blockHeight < MIN_PARCEL_SIZE * 2) {
                blockHeight = MIN_PARCEL_SIZE * 2;
            }
            double remaining = availableHeight - legendLayout.height - blockHeight;
            if (remaining < legendSpacing) {
                legendSpacing = Math.max(minSpacing, remaining);
            }
            if (legendSpacing < 0) {
                legendSpacing = 0;
            }
            double total = blockHeight + legendSpacing + legendLayout.height;
            if (total > availableHeight) {
                double excess = total - availableHeight;
                double reducible = Math.max(0, blockHeight - MIN_PARCEL_SIZE * 2);
                double reduceBlock = Math.min(reducible, excess);
                blockHeight -= reduceBlock;
                excess -= reduceBlock;
                if (excess > 0) {
                    legendSpacing = Math.max(0, legendSpacing - excess);
                }
            }
        }
        if (blockHeight > availableHeight) {
            blockHeight = availableHeight;
        }
        Rectangle2D.Double block = new Rectangle2D.Double(MARGIN, MARGIN, blockWidth, blockHeight);
        Rectangle2D.Double buildable = new Rectangle2D.Double(
                block.x + PERIMETER_ROAD,
                block.y + PERIMETER_ROAD,
                block.width - 2 * PERIMETER_ROAD,
                block.height - 2 * PERIMETER_ROAD
        );
        this.buildableArea = buildable;

        drawPerimeterRoad(g, block, buildable);

        List<Road> innerRoads = new ArrayList<Road>();
        List<Parcel> parcels = subdivideBlock(buildable, innerRoads);
        this.currentRoads = innerRoads;
        ensureRequiredBuildingTypes(parcels);

        drawInnerRoads(g, innerRoads);
        drawParcels(g, parcels);
        annotateParcels(g, parcels);
        if (legendLayout != null) {
            double legendX = block.x + (block.width - legendLayout.width) / 2.0;
            legendX = Math.max(MARGIN, Math.min(IMAGE_WIDTH - MARGIN - legendLayout.width, legendX));
            double legendY = block.y + block.height + legendSpacing;
            legendY = Math.min(IMAGE_HEIGHT - MARGIN - legendLayout.height, legendY);
            drawLegend(g, legendLayout, legendX, legendY);
        }

        g.dispose();
        return image;
    }

    private void drawPerimeterRoad(Graphics2D g, Rectangle2D.Double block, Rectangle2D.Double buildable) {
        g.setColor(ROAD_COLOR);
        g.fill(block);
        g.setColor(new Color(210, 195, 166));
        g.setStroke(new BasicStroke(5.2f));
        g.draw(block);

        g.setColor(BACKGROUND_COLOR);
        g.fill(buildable);

        // Add a radial gradient hinting at worn paving.
        Graphics2D g2 = (Graphics2D) g.create();
        int gradientRadius = (int) Math.max(block.width, block.height);
        GradientPaint gradient = new GradientPaint(
                (float) (block.getCenterX()), (float) (block.getCenterY()), new Color(193, 178, 152, 90),
                (float) (block.getCenterX()), (float) (block.getCenterY() + gradientRadius), new Color(150, 130, 100, 0)
        );
        g2.setPaint(gradient);
        g2.fill(block);
        g2.dispose();
    }

    private List<Parcel> subdivideBlock(Rectangle2D.Double buildable, List<Road> innerRoads) {
        List<Parcel> parcels = new ArrayList<Parcel>();
        Deque<Rectangle2D.Double> queue = new ArrayDeque<Rectangle2D.Double>();
        queue.add(buildable);

        while (!queue.isEmpty()) {
            Rectangle2D.Double current = queue.removeFirst();
            if (shouldSplit(current)) {
                boolean splitVertical = decideSplitOrientation(current);
                boolean createAlley = splitCreatesAlley(current);

                if (splitVertical) {
                    if (createAlley) {
                        double roadWidth = randomRange(ROAD_WIDTH_MIN, ROAD_WIDTH_MAX);
                        double splitX = randomSplitCoordinate(current.x, current.x + current.width, roadWidth);
                        Rectangle2D.Double left = new Rectangle2D.Double(current.x, current.y,
                                splitX - roadWidth / 2.0 - current.x, current.height);
                        Rectangle2D.Double right = new Rectangle2D.Double(splitX + roadWidth / 2.0, current.y,
                                current.x + current.width - (splitX + roadWidth / 2.0), current.height);
                        Rectangle2D.Double roadRect = new Rectangle2D.Double(splitX - roadWidth / 2.0, current.y, roadWidth, current.height);
                        innerRoads.add(new Road(roadRect, roadWidth));
                        enqueueIfValid(queue, left);
                        enqueueIfValid(queue, right);
                    } else {
                        double splitX = randomSplitCoordinate(current.x, current.x + current.width, 0);
                        Rectangle2D.Double left = new Rectangle2D.Double(current.x, current.y,
                                splitX - current.x, current.height);
                        Rectangle2D.Double right = new Rectangle2D.Double(splitX, current.y,
                                current.x + current.width - splitX, current.height);
                        enqueueIfValid(queue, left);
                        enqueueIfValid(queue, right);
                    }
                } else {
                    if (createAlley) {
                        double roadWidth = randomRange(ROAD_WIDTH_MIN, ROAD_WIDTH_MAX);
                        double splitY = randomSplitCoordinate(current.y, current.y + current.height, roadWidth);
                        Rectangle2D.Double top = new Rectangle2D.Double(current.x, current.y, current.width,
                                splitY - roadWidth / 2.0 - current.y);
                        Rectangle2D.Double bottom = new Rectangle2D.Double(current.x, splitY + roadWidth / 2.0, current.width,
                                current.y + current.height - (splitY + roadWidth / 2.0));
                        Rectangle2D.Double roadRect = new Rectangle2D.Double(current.x, splitY - roadWidth / 2.0, current.width, roadWidth);
                        innerRoads.add(new Road(roadRect, roadWidth));
                        enqueueIfValid(queue, top);
                        enqueueIfValid(queue, bottom);
                    } else {
                        double splitY = randomSplitCoordinate(current.y, current.y + current.height, 0);
                        Rectangle2D.Double top = new Rectangle2D.Double(current.x, current.y, current.width,
                                splitY - current.y);
                        Rectangle2D.Double bottom = new Rectangle2D.Double(current.x, splitY, current.width,
                                current.y + current.height - splitY);
                        enqueueIfValid(queue, top);
                        enqueueIfValid(queue, bottom);
                    }
                }
            } else {
                parcels.add(new Parcel(current));
            }
        }
        return parcels;
    }

    private boolean shouldSplit(Rectangle2D.Double rect) {
        double largestSide = Math.max(rect.width, rect.height);
        double smallestSide = Math.min(rect.width, rect.height);
        if (largestSide < MIN_PARCEL_SIZE * 1.5) {
            return false;
        }
        if (smallestSide < MIN_PARCEL_SIZE) {
            return false;
        }
        double area = rect.width * rect.height;
        double normalizedSide = Math.min(largestSide, buildableExtent()) / buildableExtent();
        double probability = 0.22 + 0.25 * normalizedSide;
        if (area > MIN_PARCEL_SIZE * MIN_PARCEL_SIZE * 4.5) {
            probability += 0.12;
        }
        if (area > MIN_PARCEL_SIZE * MIN_PARCEL_SIZE * 7) {
            probability += 0.08;
        }
        return random.nextDouble() < Math.min(0.85, probability);
    }

    private boolean splitCreatesAlley(Rectangle2D.Double rect) {
        double largestSide = Math.max(rect.width, rect.height);
        double smallestSide = Math.min(rect.width, rect.height);
        if (smallestSide < MIN_PARCEL_SIZE * 1.35) {
            return false;
        }
        double area = rect.width * rect.height;
        double thresholdArea = MIN_PARCEL_SIZE * MIN_PARCEL_SIZE * 3.2;
        double probability = 0.14;
        if (area > thresholdArea * 1.8) {
            probability += 0.07;
        }
        return random.nextDouble() < probability;
    }

    private boolean decideSplitOrientation(Rectangle2D.Double rect) {
        if (rect.width > rect.height * 1.4) {
            return true;
        }
        if (rect.height > rect.width * 1.4) {
            return false;
        }
        return random.nextBoolean();
    }

    private double randomSplitCoordinate(double minEdge, double maxEdge, double roadWidth) {
        double min = minEdge + MIN_PARCEL_SIZE + roadWidth / 2.0;
        double max = maxEdge - MIN_PARCEL_SIZE - roadWidth / 2.0;
        if (max <= min) {
            return (minEdge + maxEdge) / 2.0;
        }
        return min + random.nextDouble() * (max - min);
    }

    private void enqueueIfValid(Deque<Rectangle2D.Double> queue, Rectangle2D.Double rect) {
        if (rect.width > 30 && rect.height > 30) {
            queue.add(rect);
        }
    }

    private double buildableExtent() {
        return IMAGE_WIDTH - 2 * (MARGIN + PERIMETER_ROAD);
    }

    private void ensureRequiredBuildingTypes(List<Parcel> parcels) {
        Collections.sort(parcels, new Comparator<Parcel>() {
            @Override
            public int compare(Parcel o1, Parcel o2) {
                double area1 = o1.area();
                double area2 = o2.area();
                return Double.compare(area2, area1);
            }
        });

        if (parcels.isEmpty()) {
            return;
        }

        Parcel churchParcel = chooseCentralParcel(parcels);
        churchParcel.type = BuildingType.CHURCH;

        int tenements = Math.max(1, parcels.size() / 6);
        int assignedTenements = assignLargestParcels(parcels, BuildingType.TENEMENT, tenements, churchParcel);
        if (assignedTenements == 0) {
            assignFallbackByArea(parcels, BuildingType.TENEMENT, churchParcel);
        }

        Parcel parkParcel = chooseParkParcel(parcels, churchParcel);
        if (parkParcel != null && parkParcel.type == BuildingType.UNASSIGNED) {
            parkParcel.type = BuildingType.PARK;
        }

        assignShops(parcels);
        assignHouses(parcels);
        assignRemaining(parcels);

        ensureTypePresence(parcels, BuildingType.PARK, parkParcel);
        ensureTypePresence(parcels, BuildingType.SHOP, null);
        ensureTypePresence(parcels, BuildingType.PRIVATE_HOUSE, null);
        ensureTypePresence(parcels, BuildingType.TENEMENT, churchParcel);
    }

    private Parcel chooseCentralParcel(List<Parcel> parcels) {
        double centerX = IMAGE_WIDTH / 2.0;
        double centerY = IMAGE_HEIGHT / 2.0;
        Parcel best = parcels.get(0);
        double bestScore = Double.MAX_VALUE;
        for (Parcel parcel : parcels) {
            double dx = parcel.rect.getCenterX() - centerX;
            double dy = parcel.rect.getCenterY() - centerY;
            double distance = Math.hypot(dx, dy);
            double areaScore = parcel.area();
            double score = distance * 0.7 - areaScore * (0.0005 / (SCALE * SCALE));
            if (parcel.type == BuildingType.UNASSIGNED && score < bestScore) {
                bestScore = score;
                best = parcel;
            }
        }
        return best;
    }

    private int assignLargestParcels(List<Parcel> parcels, BuildingType type, int count, Parcel exclude) {
        int assigned = 0;
        for (Parcel parcel : parcels) {
            if (parcel == exclude) {
                continue;
            }
            if (parcel.type == BuildingType.UNASSIGNED && parcel.area() > 14000 * SCALE * SCALE) {
                parcel.type = type;
                assigned++;
            }
            if (assigned >= count) {
                break;
            }
        }
        return assigned;
    }

    private void assignFallbackByArea(List<Parcel> parcels, BuildingType type, Parcel exclude) {
        for (Parcel parcel : parcels) {
            if (parcel != exclude && parcel.type == BuildingType.UNASSIGNED) {
                parcel.type = type;
                return;
            }
        }
    }

    private Parcel chooseParkParcel(List<Parcel> parcels, Parcel churchParcel) {
        Parcel candidate = null;
        double bestScore = Double.NEGATIVE_INFINITY;
        for (Parcel parcel : parcels) {
            if (parcel == churchParcel || parcel.type != BuildingType.UNASSIGNED) {
                continue;
            }
            double openScore = 1.0 / (1.0 + Math.abs(parcel.rect.width - parcel.rect.height));
            double borderScore = Math.min(distanceToEdge(parcel.rect), 120 * SCALE);
            double areaScore = Math.log(Math.max(parcel.area(), 1));
            double score = openScore * 1.2 + borderScore * 0.015 + areaScore * 0.12;
            if (score > bestScore) {
                bestScore = score;
                candidate = parcel;
            }
        }
        return candidate;
    }

    private double distanceToEdge(Rectangle2D.Double rect) {
        double left = rect.x - MARGIN;
        double right = IMAGE_WIDTH - MARGIN - (rect.x + rect.width);
        double top = rect.y - MARGIN;
        double bottom = IMAGE_HEIGHT - MARGIN - (rect.y + rect.height);
        return Math.min(Math.min(left, right), Math.min(top, bottom));
    }

    private void assignShops(List<Parcel> parcels) {
        List<Parcel> candidates = new ArrayList<Parcel>();
        for (Parcel parcel : parcels) {
            if (parcel.type == BuildingType.UNASSIGNED && Math.min(parcel.rect.width, parcel.rect.height) < 140 * SCALE) {
                candidates.add(parcel);
            }
        }
        if (candidates.isEmpty()) {
            for (Parcel parcel : parcels) {
                if (parcel.type == BuildingType.UNASSIGNED) {
                    candidates.add(parcel);
                }
            }
        }
        int shops = Math.max(2, parcels.size() / 8);
        Collections.shuffle(candidates, random);
        for (int i = 0; i < Math.min(shops, candidates.size()); i++) {
            candidates.get(i).type = BuildingType.SHOP;
        }
    }

    private void assignHouses(List<Parcel> parcels) {
        for (Parcel parcel : parcels) {
            if (parcel.type == BuildingType.UNASSIGNED && parcel.area() < 22000 * SCALE * SCALE) {
                parcel.type = BuildingType.PRIVATE_HOUSE;
            }
        }
    }

    private void assignRemaining(List<Parcel> parcels) {
        for (Parcel parcel : parcels) {
            if (parcel.type == BuildingType.UNASSIGNED) {
                if (parcel.area() > 26000 * SCALE * SCALE) {
                    parcel.type = BuildingType.TENEMENT;
                } else if (random.nextDouble() < 0.3) {
                    parcel.type = BuildingType.PARK;
                } else {
                    parcel.type = BuildingType.PRIVATE_HOUSE;
                }
            }
        }
    }

    private void ensureTypePresence(List<Parcel> parcels, BuildingType type, Parcel exclude) {
        if (hasType(parcels, type)) {
            return;
        }
        switch (type) {
            case PARK:
                Parcel parkCandidate = chooseParkParcel(parcels, exclude);
                if (parkCandidate != null) {
                    parkCandidate.type = BuildingType.PARK;
                }
                break;
            case SHOP:
                Parcel shopCandidate = findBestByComparator(parcels, new Comparator<Parcel>() {
                    @Override
                    public int compare(Parcel a, Parcel b) {
                        double scoreA = Math.min(a.rect.width, a.rect.height);
                        double scoreB = Math.min(b.rect.width, b.rect.height);
                        return Double.compare(scoreA, scoreB);
                    }
                }, exclude);
                if (shopCandidate != null) {
                    shopCandidate.type = BuildingType.SHOP;
                }
                break;
            case PRIVATE_HOUSE:
                Parcel houseCandidate = findBestByComparator(parcels, new Comparator<Parcel>() {
                    @Override
                    public int compare(Parcel a, Parcel b) {
                        double target = 15000 * SCALE * SCALE;
                        return Double.compare(Math.abs(a.area() - target), Math.abs(b.area() - target));
                    }
                }, exclude);
                if (houseCandidate != null) {
                    houseCandidate.type = BuildingType.PRIVATE_HOUSE;
                }
                break;
            case TENEMENT:
                Parcel tenementCandidate = findBestByComparator(parcels, new Comparator<Parcel>() {
                    @Override
                    public int compare(Parcel a, Parcel b) {
                        return Double.compare(b.area(), a.area());
                    }
                }, exclude);
                if (tenementCandidate != null) {
                    tenementCandidate.type = BuildingType.TENEMENT;
                }
                break;
            default:
                break;
        }
    }

    private boolean hasType(List<Parcel> parcels, BuildingType type) {
        for (Parcel parcel : parcels) {
            if (parcel.type == type) {
                return true;
            }
        }
        return false;
    }

    private Parcel findBestByComparator(List<Parcel> parcels, Comparator<Parcel> comparator, Parcel exclude) {
        Parcel best = null;
        for (Parcel parcel : parcels) {
            if (parcel == exclude || parcel.type == BuildingType.CHURCH) {
                continue;
            }
            if (best == null) {
                best = parcel;
                continue;
            }
            int penaltyBest = typePenalty(best.type);
            int penaltyParcel = typePenalty(parcel.type);
            if (penaltyParcel != penaltyBest) {
                if (penaltyParcel < penaltyBest) {
                    best = parcel;
                }
            } else if (comparator.compare(parcel, best) < 0) {
                best = parcel;
            }
        }
        return best;
    }

    private int typePenalty(BuildingType type) {
        if (type == BuildingType.UNASSIGNED) {
            return 0;
        }
        if (type == BuildingType.PRIVATE_HOUSE) {
            return 1;
        }
        if (type == BuildingType.PARK || type == BuildingType.SHOP) {
            return 2;
        }
        if (type == BuildingType.TENEMENT) {
            return 3;
        }
        return 4;
    }

    private void drawInnerRoads(Graphics2D g, List<Road> innerRoads) {
        g.setColor(ALLEY_COLOR);
        for (Road road : innerRoads) {
            g.fill(road.rect);
            Graphics2D g2 = (Graphics2D) g.create();
            g2.setColor(new Color(180, 160, 130));
            g2.setStroke(new BasicStroke(Math.max(1.8f, (float) (road.width / 5.2))));
            g2.draw(road.rect);
            g2.dispose();
        }
    }

    private void drawParcels(Graphics2D g, List<Parcel> parcels) {
        for (Parcel parcel : parcels) {
            BuildingType type = parcel.type != null ? parcel.type : BuildingType.PRIVATE_HOUSE;
            g.setColor(type.fillColor);
            g.fill(parcel.rect);

            Graphics2D planGraphics = (Graphics2D) g.create();
            planGraphics.clip(parcel.rect);
            Edge entrance = findEntranceSide(parcel);
            EnumSet<Edge> partyWalls = findPartyWalls(parcel, parcels);
            drawFloorPlan(planGraphics, parcel.rect, type, entrance, partyWalls);
            planGraphics.dispose();

            g.setColor(type.strokeColor);
            g.setStroke(new BasicStroke(3.0f));
            g.draw(parcel.rect);
        }
    }

    private EnumSet<Edge> findPartyWalls(Parcel parcel, List<Parcel> parcels) {
        EnumSet<Edge> partyWalls = EnumSet.noneOf(Edge.class);
        Rectangle2D.Double rect = parcel.rect;
        boolean residential = parcel.type == BuildingType.PRIVATE_HOUSE || parcel.type == BuildingType.TENEMENT;
        double generalThreshold = Math.max(3.0, 3.0 * SCALE);
        double residentialThreshold = Math.max(2.0, 2.2 * SCALE);

        for (Edge edge : Edge.values()) {
            if (touchesPerimeter(rect, edge)) {
                continue;
            }

            double bestAccessible = 0;
            for (Parcel other : parcels) {
                if (other == parcel) {
                    continue;
                }
                double accessible = accessibleSharedLength(rect, edge, other.rect);
                if (accessible > bestAccessible) {
                    bestAccessible = accessible;
                }
            }

            double threshold = residential ? residentialThreshold : generalThreshold;
            if (bestAccessible > threshold) {
                partyWalls.add(edge);
            }
        }

        return partyWalls;
    }

    private double accessibleSharedLength(Rectangle2D.Double rect, Edge edge, Rectangle2D.Double other) {
        double[] interval = edgeOverlapInterval(rect, edge, other, false);
        if (interval == null) {
            return 0;
        }
        double length = interval[1] - interval[0];
        if (length <= 0) {
            return 0;
        }
        double blocked = roadOverlapOnInterval(rect, edge, interval);
        double accessible = length - blocked;
        return Math.max(0, accessible);
    }

    private void drawFloorPlan(Graphics2D g, Rectangle2D.Double rect, BuildingType type, Edge entrance, EnumSet<Edge> partyWalls) {
        g.setColor(FLOOR_TONE);
        g.fill(rect);

        switch (type) {
            case CHURCH:
                drawChurchPlan(g, rect, entrance, partyWalls);
                break;
            case TENEMENT:
                drawTenementPlan(g, rect, entrance, partyWalls);
                break;
            case SHOP:
                drawShopPlan(g, rect, entrance, partyWalls);
                break;
            case PARK:
                drawParkPlan(g, rect);
                break;
            case PRIVATE_HOUSE:
            default:
                drawHousePlan(g, rect, entrance, partyWalls);
                break;
        }
    }

    private void drawHousePlan(Graphics2D g, Rectangle2D.Double rect, Edge entrance, EnumSet<Edge> partyWalls) {
        Graphics2D g2 = (Graphics2D) g.create();
        double doorSpan = orientedSpan(rect, entrance) * 0.24;
        drawOuterWall(g2, rect, entrance, doorSpan, partyWalls);

        double span = orientedSpan(rect, entrance);
        double depth = perpendicularSpan(rect, entrance);

        double vestibulumDepth = clamp(depth * 0.12, 26, depth * 0.18);
        double atriumDepth = clamp(depth * 0.26, 74, depth * 0.32);
        double tablinumDepth = clamp(depth * 0.12, 34, depth * 0.18);
        double peristyleDepth = clamp(depth * 0.28, 84, depth * 0.36);

        double baseConsumed = vestibulumDepth + atriumDepth + tablinumDepth + peristyleDepth;
        if (baseConsumed > depth * 0.84) {
            double deficit = baseConsumed - depth * 0.84;
            peristyleDepth = Math.max(depth * 0.22, peristyleDepth - deficit * 0.55);
            atriumDepth = Math.max(depth * 0.2, atriumDepth - deficit * 0.25);
            tablinumDepth = Math.max(depth * 0.08, tablinumDepth - deficit * 0.12);
            vestibulumDepth = Math.max(depth * 0.08, vestibulumDepth - deficit * 0.08);
            baseConsumed = vestibulumDepth + atriumDepth + tablinumDepth + peristyleDepth;
        }

        double remaining = Math.max(depth - baseConsumed, depth * 0.18);
        double serviceDepth = clamp(depth * 0.12, 34, depth * 0.18);
        if (serviceDepth > remaining * 0.45) {
            serviceDepth = Math.max(30, remaining * 0.45);
        }
        double hortusDepth = Math.max(48, remaining - serviceDepth);
        if (hortusDepth < 36) {
            hortusDepth = 36;
            serviceDepth = Math.max(30, remaining - hortusDepth);
        }

        double consumed = baseConsumed + hortusDepth + serviceDepth;
        if (consumed > depth) {
            double deficit = consumed - depth;
            hortusDepth = Math.max(32, hortusDepth - deficit * 0.5);
            peristyleDepth = Math.max(depth * 0.2, peristyleDepth - deficit * 0.3);
            atriumDepth = Math.max(depth * 0.18, atriumDepth - deficit * 0.15);
            vestibulumDepth = Math.max(depth * 0.07, vestibulumDepth - deficit * 0.05);
        }

        double sideBands = clamp(span * 0.18, 34, span * 0.26);
        if (sideBands * 2 > span - 40) {
            sideBands = Math.max(26, (span - 40) / 2.0);
        }
        double axialWidth = Math.max(span - sideBands * 2, span * 0.42);
        if (axialWidth > span - 32) {
            axialWidth = span - 32;
        }
        double axialMargin = Math.max((span - axialWidth) / 2.0, 12);

        double cursor = 0;

        double shopDepth = Math.min(vestibulumDepth * 0.9, vestibulumDepth);
        Rectangle2D.Double tabernaLeft = orientedLocalRect(rect, entrance, 0, 0, sideBands, shopDepth);
        Rectangle2D.Double tabernaRight = orientedLocalRect(rect, entrance, span - sideBands, 0, sideBands, shopDepth);
        g2.setColor(new Color(212, 195, 164));
        g2.fill(tabernaLeft);
        g2.fill(tabernaRight);

        Rectangle2D.Double vestibulum = orientedLocalRect(rect, entrance, axialMargin, cursor, axialWidth, vestibulumDepth);
        g2.setColor(WALKWAY_TONE);
        g2.fill(vestibulum);

        Rectangle2D.Double fauces = orientedLocalRect(rect, entrance, axialMargin + axialWidth * 0.34, cursor, axialWidth * 0.32, vestibulumDepth);
        g2.setColor(new Color(223, 210, 188));
        g2.fill(fauces);
        cursor += vestibulumDepth;

        double atriumMargin = Math.max(axialMargin - sideBands * 0.2, 10);
        double atriumWidth = span - 2 * atriumMargin;
        Rectangle2D.Double atrium = orientedLocalRect(rect, entrance, atriumMargin, cursor, atriumWidth, atriumDepth);
        g2.setColor(new Color(232, 219, 196));
        g2.fill(atrium);

        Rectangle2D.Double compluvium = insetRect(atrium, atrium.width * 0.12, atrium.height * 0.12);
        g2.setColor(WALKWAY_TONE);
        g2.fill(compluvium);

        Rectangle2D.Double impluvium = insetRect(compluvium, compluvium.width * 0.38, compluvium.height * 0.4);
        g2.setColor(new Color(166, 198, 212));
        g2.fill(impluvium);

        Rectangle2D.Double alaLeft = orientedLocalRect(rect, entrance, 0, cursor + atriumDepth * 0.16, sideBands, atriumDepth * 0.68);
        Rectangle2D.Double alaRight = orientedLocalRect(rect, entrance, span - sideBands, cursor + atriumDepth * 0.16, sideBands, atriumDepth * 0.68);
        g2.setColor(new Color(221, 206, 178));
        g2.fill(alaLeft);
        g2.fill(alaRight);

        Rectangle2D.Double cubiculaFrontLeft = orientedLocalRect(rect, entrance, 0, cursor - vestibulumDepth * 0.2, sideBands, atriumDepth * 0.4);
        Rectangle2D.Double cubiculaFrontRight = orientedLocalRect(rect, entrance, span - sideBands, cursor - vestibulumDepth * 0.2, sideBands, atriumDepth * 0.4);
        Rectangle2D.Double cubiculaRearLeft = orientedLocalRect(rect, entrance, 0, cursor + atriumDepth * 0.54, sideBands, atriumDepth * 0.5);
        Rectangle2D.Double cubiculaRearRight = orientedLocalRect(rect, entrance, span - sideBands, cursor + atriumDepth * 0.54, sideBands, atriumDepth * 0.5);
        g2.setColor(new Color(223, 207, 182));
        g2.fill(cubiculaFrontLeft);
        g2.fill(cubiculaFrontRight);
        g2.fill(cubiculaRearLeft);
        g2.fill(cubiculaRearRight);

        Rectangle2D.Double lararium = orientedLocalRect(rect, entrance, atriumMargin + atriumWidth * 0.35, cursor + atriumDepth * 0.06, atriumWidth * 0.3, atriumDepth * 0.2);
        g2.setColor(new Color(214, 198, 163));
        g2.fill(lararium);

        g2.setColor(WALL_TONE);
        g2.setStroke(new BasicStroke(2.8f));
        g2.draw(vestibulum);
        g2.draw(fauces);
        g2.draw(atrium);
        g2.draw(alaLeft);
        g2.draw(alaRight);
        g2.draw(cubiculaFrontLeft);
        g2.draw(cubiculaFrontRight);
        g2.draw(cubiculaRearLeft);
        g2.draw(cubiculaRearRight);

        cursor += atriumDepth;

        double tablinumMargin = Math.max(axialMargin + axialWidth * 0.08, atriumMargin + atriumWidth * 0.08);
        double tablinumWidth = Math.min(span - 2 * tablinumMargin, axialWidth * 0.9);
        Rectangle2D.Double tablinum = orientedLocalRect(rect, entrance, tablinumMargin, cursor, tablinumWidth, tablinumDepth);
        g2.setColor(new Color(226, 210, 185));
        g2.fill(tablinum);

        Rectangle2D.Double alaeTablinumLeft = orientedLocalRect(rect, entrance, 0, cursor, sideBands, tablinumDepth * 0.9);
        Rectangle2D.Double alaeTablinumRight = orientedLocalRect(rect, entrance, span - sideBands, cursor, sideBands, tablinumDepth * 0.9);
        g2.setColor(new Color(220, 204, 178));
        g2.fill(alaeTablinumLeft);
        g2.fill(alaeTablinumRight);

        g2.setColor(WALL_TONE);
        g2.draw(tablinum);
        g2.draw(alaeTablinumLeft);
        g2.draw(alaeTablinumRight);

        cursor += tablinumDepth;

        double peristyleMargin = Math.max(sideBands * 0.6, 18);
        double peristyleWidth = span - 2 * peristyleMargin;
        Rectangle2D.Double peristyle = orientedLocalRect(rect, entrance, peristyleMargin, cursor, peristyleWidth, peristyleDepth);
        g2.setColor(WALKWAY_TONE);
        g2.fill(peristyle);

        Rectangle2D.Double viridarium = insetRect(peristyle, peristyle.width * 0.22, peristyle.height * 0.25);
        g2.setColor(new Color(168, 190, 132));
        g2.fill(viridarium);
        drawPeristyleColonnade(g2, peristyle);

        Rectangle2D.Double exedra = orientedLocalRect(rect, entrance, peristyleMargin + peristyleWidth * 0.22, cursor + peristyleDepth * 0.62, peristyleWidth * 0.56, peristyleDepth * 0.32);
        g2.setColor(new Color(219, 205, 180));
        g2.fill(exedra);

        Rectangle2D.Double triclinium = orientedLocalRect(rect, entrance, peristyleMargin - sideBands * 0.15, cursor + peristyleDepth * 0.18, sideBands * 0.9, peristyleDepth * 0.52);
        Rectangle2D.Double oecus = orientedLocalRect(rect, entrance, peristyleMargin + peristyleWidth, cursor + peristyleDepth * 0.2, sideBands * 0.9, peristyleDepth * 0.5);
        g2.setColor(new Color(222, 208, 182));
        g2.fill(triclinium);
        g2.fill(oecus);

        Rectangle2D.Double culina = orientedLocalRect(rect, entrance, peristyleMargin + peristyleWidth * 0.66, cursor + peristyleDepth * 0.22, peristyleWidth * 0.28, peristyleDepth * 0.36);
        Rectangle2D.Double bathSuite = orientedLocalRect(rect, entrance, peristyleMargin + peristyleWidth * 0.68, cursor + peristyleDepth * 0.64, peristyleWidth * 0.26, peristyleDepth * 0.32);
        g2.setColor(new Color(207, 191, 165));
        g2.fill(culina);
        g2.setColor(new Color(196, 182, 158));
        g2.fill(bathSuite);

        Rectangle2D.Double hearth = insetRect(culina, culina.width * 0.22, culina.height * 0.24);
        g2.setColor(new Color(187, 106, 64));
        g2.fill(hearth);

        Rectangle2D.Double balneum = insetRect(bathSuite, bathSuite.width * 0.18, bathSuite.height * 0.22);
        g2.setColor(new Color(176, 198, 212));
        g2.fill(balneum);

        g2.setColor(WALL_TONE);
        g2.draw(peristyle);
        g2.draw(exedra);
        g2.draw(triclinium);
        g2.draw(oecus);
        g2.draw(culina);
        g2.draw(bathSuite);

        cursor += peristyleDepth;

        Rectangle2D.Double hortus = orientedLocalRect(rect, entrance, axialMargin, cursor, axialWidth, hortusDepth);
        g2.setColor(new Color(170, 192, 138));
        g2.fill(hortus);

        Rectangle2D.Double pergola = orientedLocalRect(rect, entrance, axialMargin + axialWidth * 0.22, cursor + hortusDepth * 0.18, axialWidth * 0.56, hortusDepth * 0.28);
        Rectangle2D.Double fountain = insetRect(hortus, axialWidth * 0.34, hortusDepth * 0.3);
        g2.setColor(new Color(158, 182, 120));
        g2.fill(pergola);
        g2.setColor(new Color(166, 198, 212));
        g2.fill(fountain);

        g2.setColor(WALL_TONE);
        g2.draw(hortus);
        g2.draw(pergola);

        cursor += hortusDepth;

        Rectangle2D.Double serviceRange = orientedLocalRect(rect, entrance, 0, cursor, span, serviceDepth);
        g2.setColor(new Color(210, 196, 168));
        g2.fill(serviceRange);

        Rectangle2D.Double slaveQuarters = orientedLocalRect(rect, entrance, 0, cursor, sideBands, serviceDepth);
        Rectangle2D.Double storage = orientedLocalRect(rect, entrance, span - sideBands, cursor, sideBands, serviceDepth);
        Rectangle2D.Double serviceCourt = orientedLocalRect(rect, entrance, axialMargin, cursor + serviceDepth * 0.08, axialWidth * 0.5, serviceDepth * 0.62);
        Rectangle2D.Double latrine = orientedLocalRect(rect, entrance, axialMargin + axialWidth * 0.56, cursor + serviceDepth * 0.2, axialWidth * 0.18, serviceDepth * 0.48);
        Rectangle2D.Double postern = orientedLocalRect(rect, entrance, axialMargin + axialWidth * 0.32, cursor + serviceDepth * 0.72, axialWidth * 0.36, serviceDepth * 0.22);
        g2.setColor(new Color(204, 188, 160));
        g2.fill(slaveQuarters);
        g2.fill(storage);
        g2.setColor(new Color(214, 200, 172));
        g2.fill(serviceCourt);
        g2.setColor(new Color(187, 203, 178));
        g2.fill(latrine);
        g2.setColor(WALKWAY_TONE);
        g2.fill(postern);

        g2.setColor(WALL_TONE);
        g2.draw(serviceRange);
        g2.draw(slaveQuarters);
        g2.draw(storage);
        g2.draw(serviceCourt);
        g2.draw(latrine);
        g2.draw(postern);
        g2.draw(tabernaLeft);
        g2.draw(tabernaRight);

        g2.dispose();
    }


    private void drawTenementPlan(Graphics2D g, Rectangle2D.Double rect, Edge entrance, EnumSet<Edge> partyWalls) {
        Graphics2D g2 = (Graphics2D) g.create();
        double doorSpan = orientedSpan(rect, entrance) * 0.22;
        drawOuterWall(g2, rect, entrance, doorSpan, partyWalls);

        double span = orientedSpan(rect, entrance);
        double depth = perpendicularSpan(rect, entrance);

        double arcadeDepth = clamp(depth * 0.1, 20, depth * 0.16);
        double tabernaDepth = clamp(depth * 0.18, 42, depth * 0.26);
        double courtyardDepth = clamp(depth * 0.28, 60, depth * 0.34);
        double rearWingDepth = clamp(depth * 0.22, 54, depth * 0.3);
        double serviceDepth = Math.max(34, depth - (arcadeDepth + tabernaDepth + courtyardDepth + rearWingDepth));
        double total = arcadeDepth + tabernaDepth + courtyardDepth + rearWingDepth + serviceDepth;
        if (total > depth) {
            double deficit = total - depth;
            rearWingDepth = Math.max(depth * 0.18, rearWingDepth - deficit * 0.4);
            courtyardDepth = Math.max(depth * 0.22, courtyardDepth - deficit * 0.32);
            tabernaDepth = Math.max(depth * 0.16, tabernaDepth - deficit * 0.16);
            arcadeDepth = Math.max(depth * 0.08, arcadeDepth - deficit * 0.12);
            serviceDepth = Math.max(30, depth - (arcadeDepth + tabernaDepth + courtyardDepth + rearWingDepth));
        }

        double walkwayWidth = clamp(span * 0.06, 12, span * 0.1);
        double wingWidth = clamp(span * 0.18, 36, span * 0.26);
        double courtyardWidth = span - 2 * (wingWidth + walkwayWidth);
        if (courtyardWidth < span * 0.36) {
            double shortage = span * 0.36 - courtyardWidth;
            wingWidth = Math.max(28, wingWidth - shortage / 2.0);
            courtyardWidth = span - 2 * (wingWidth + walkwayWidth);
        }
        if (courtyardWidth > span * 0.62) {
            courtyardWidth = span * 0.62;
            wingWidth = Math.max(30, (span - courtyardWidth) / 2.0 - walkwayWidth);
        }
        double courtyardMargin = wingWidth + walkwayWidth;

        double cursor = 0;

        Rectangle2D.Double arcade = orientedLocalRect(rect, entrance, 0, cursor, span, arcadeDepth);
        g2.setColor(WALKWAY_TONE);
        g2.fill(arcade);
        cursor += arcadeDepth;

        Rectangle2D.Double tabernae = orientedLocalRect(rect, entrance, 0, cursor, span, tabernaDepth);
        g2.setColor(new Color(221, 205, 178));
        g2.fill(tabernae);
        g2.setColor(WALL_TONE);
        g2.setStroke(new BasicStroke(2.7f));
        int shopCount = Math.max(3, (int) Math.round(span / (140.0 * SCALE))) + random.nextInt(2);
        double shopWidth = tabernae.width / shopCount;
        for (int i = 1; i < shopCount; i++) {
            double x = tabernae.x + i * shopWidth;
            g2.draw(new Line2D.Double(x, tabernae.y, x, tabernae.getMaxY()));
        }

        Rectangle2D.Double vestibule = orientedLocalRect(rect, entrance, courtyardMargin - walkwayWidth * 0.5, cursor - arcadeDepth * 0.4, walkwayWidth, arcadeDepth + tabernaDepth * 0.8);
        g2.setColor(WALKWAY_TONE);
        g2.fill(vestibule);

        cursor += tabernaDepth;

        double wingHeight = courtyardDepth + rearWingDepth;
        Rectangle2D.Double westWing = orientedLocalRect(rect, entrance, 0, cursor, wingWidth, wingHeight);
        Rectangle2D.Double eastWing = orientedLocalRect(rect, entrance, span - wingWidth, cursor, wingWidth, wingHeight);
        g2.setColor(new Color(222, 206, 179));
        g2.fill(westWing);
        g2.fill(eastWing);

        Rectangle2D.Double westRooms = orientedLocalRect(rect, entrance, 0, cursor, wingWidth, courtyardDepth * 0.55);
        Rectangle2D.Double eastRooms = orientedLocalRect(rect, entrance, span - wingWidth, cursor, wingWidth, courtyardDepth * 0.55);
        g2.setStroke(new BasicStroke(2.6f));
        g2.draw(westRooms);
        g2.draw(eastRooms);

        Rectangle2D.Double walkwayWest = orientedLocalRect(rect, entrance, wingWidth, cursor, walkwayWidth, courtyardDepth);
        Rectangle2D.Double walkwayEast = orientedLocalRect(rect, entrance, span - wingWidth - walkwayWidth, cursor, walkwayWidth, courtyardDepth);
        Rectangle2D.Double walkwaySouth = orientedLocalRect(rect, entrance, courtyardMargin, cursor, courtyardWidth, walkwayWidth);
        Rectangle2D.Double walkwayNorth = orientedLocalRect(rect, entrance, courtyardMargin, cursor + courtyardDepth - walkwayWidth, courtyardWidth, walkwayWidth);
        g2.setColor(WALKWAY_TONE);
        g2.fill(walkwayWest);
        g2.fill(walkwayEast);
        g2.fill(walkwaySouth);
        g2.fill(walkwayNorth);

        Rectangle2D.Double courtyard = orientedLocalRect(rect, entrance, courtyardMargin, cursor, courtyardWidth, courtyardDepth);
        g2.setColor(new Color(224, 210, 184));
        g2.fill(courtyard);

        Rectangle2D.Double plantingBeds = insetRect(courtyard, courtyard.width * 0.18, courtyard.height * 0.18);
        g2.setColor(new Color(186, 200, 162));
        g2.fill(plantingBeds);

        Rectangle2D.Double cistern = insetRect(courtyard, courtyard.width * 0.32, courtyard.height * 0.32);
        g2.setColor(new Color(182, 204, 214));
        g2.fill(cistern);
        g2.setColor(WALL_TONE);
        g2.setStroke(new BasicStroke(2.6f));
        g2.draw(cistern);

        double wellRadius = Math.min(courtyard.width, courtyard.height) * 0.12;
        Ellipse2D.Double well = new Ellipse2D.Double(courtyard.getCenterX() - wellRadius, courtyard.getCenterY() - wellRadius, wellRadius * 2, wellRadius * 2);
        g2.setColor(new Color(166, 198, 212));
        g2.fill(well);
        g2.setColor(WALL_TONE);
        g2.draw(well);

        Rectangle2D.Double walkwayBridge = orientedLocalRect(rect, entrance, courtyardMargin + courtyardWidth * 0.36, cursor + courtyardDepth * 0.46, courtyardWidth * 0.28, walkwayWidth);
        g2.setColor(WALKWAY_TONE);
        g2.fill(walkwayBridge);

        Rectangle2D.Double manager = orientedLocalRect(rect, entrance, courtyardMargin + courtyardWidth * 0.72, cursor + walkwayWidth * 1.6, courtyardWidth * 0.18, courtyardDepth * 0.32);
        Rectangle2D.Double chapel = orientedLocalRect(rect, entrance, courtyardMargin + courtyardWidth * 0.08, cursor + courtyardDepth * 0.52, courtyardWidth * 0.18, courtyardDepth * 0.28);
        g2.setColor(new Color(214, 200, 172));
        g2.fill(manager);
        g2.setColor(new Color(210, 194, 170));
        g2.fill(chapel);

        Rectangle2D.Double stairFrontLeft = orientedLocalRect(rect, entrance, wingWidth, cursor + walkwayWidth * 0.5, walkwayWidth, courtyardDepth * 0.28);
        Rectangle2D.Double stairFrontRight = orientedLocalRect(rect, entrance, span - wingWidth - walkwayWidth, cursor + walkwayWidth * 0.5, walkwayWidth, courtyardDepth * 0.28);
        Rectangle2D.Double stairRearLeft = orientedLocalRect(rect, entrance, wingWidth, cursor + courtyardDepth - walkwayWidth * 0.7 - courtyardDepth * 0.28, walkwayWidth, courtyardDepth * 0.28);
        Rectangle2D.Double stairRearRight = orientedLocalRect(rect, entrance, span - wingWidth - walkwayWidth, cursor + courtyardDepth - walkwayWidth * 0.7 - courtyardDepth * 0.28, walkwayWidth, courtyardDepth * 0.28);
        g2.setColor(new Color(205, 188, 160));
        g2.fill(stairFrontLeft);
        g2.fill(stairFrontRight);
        g2.fill(stairRearLeft);
        g2.fill(stairRearRight);

        g2.setColor(WALL_TONE);
        g2.setStroke(new BasicStroke(2.6f));
        g2.draw(arcade);
        g2.draw(tabernae);
        g2.draw(westWing);
        g2.draw(eastWing);
        g2.draw(courtyard);
        g2.draw(walkwayBridge);
        g2.draw(manager);
        g2.draw(chapel);
        g2.draw(stairFrontLeft);
        g2.draw(stairFrontRight);
        g2.draw(stairRearLeft);
        g2.draw(stairRearRight);

        cursor += courtyardDepth;

        Rectangle2D.Double rearGallery = orientedLocalRect(rect, entrance, courtyardMargin, cursor, courtyardWidth, walkwayWidth * 1.1);
        g2.setColor(WALKWAY_TONE);
        g2.fill(rearGallery);

        Rectangle2D.Double rearBlock = orientedLocalRect(rect, entrance, courtyardMargin, cursor + walkwayWidth * 1.1, courtyardWidth, rearWingDepth - walkwayWidth * 1.1);
        g2.setColor(new Color(222, 206, 179));
        g2.fill(rearBlock);
        g2.setColor(WALL_TONE);
        int rearUnits = Math.max(3, (int) Math.round(courtyardWidth / 90.0));
        double rearStep = rearBlock.width / rearUnits;
        for (int i = 1; i < rearUnits; i++) {
            double x = rearBlock.x + i * rearStep;
            g2.draw(new Line2D.Double(x, rearBlock.y, x, rearBlock.getMaxY()));
        }
        g2.draw(rearBlock);

        Rectangle2D.Double loftsWest = orientedLocalRect(rect, entrance, 0, cursor, wingWidth, rearWingDepth);
        Rectangle2D.Double loftsEast = orientedLocalRect(rect, entrance, span - wingWidth, cursor, wingWidth, rearWingDepth);
        g2.setColor(new Color(218, 202, 176));
        g2.fill(loftsWest);
        g2.fill(loftsEast);
        g2.setColor(WALL_TONE);
        g2.draw(loftsWest);
        g2.draw(loftsEast);

        cursor += rearWingDepth;

        Rectangle2D.Double serviceCourt = orientedLocalRect(rect, entrance, courtyardMargin, cursor, courtyardWidth, serviceDepth);
        g2.setColor(new Color(210, 196, 168));
        g2.fill(serviceCourt);

        Rectangle2D.Double laundry = orientedLocalRect(rect, entrance, courtyardMargin + courtyardWidth * 0.05, cursor + serviceDepth * 0.2, courtyardWidth * 0.2, serviceDepth * 0.5);
        Rectangle2D.Double cisternYard = orientedLocalRect(rect, entrance, courtyardMargin + courtyardWidth * 0.38, cursor + serviceDepth * 0.18, courtyardWidth * 0.18, serviceDepth * 0.54);
        Rectangle2D.Double latrine = orientedLocalRect(rect, entrance, courtyardMargin + courtyardWidth * 0.62, cursor + serviceDepth * 0.28, courtyardWidth * 0.26, serviceDepth * 0.48);
        Rectangle2D.Double dryingYard = orientedLocalRect(rect, entrance, courtyardMargin + courtyardWidth * 0.32, cursor + serviceDepth * 0.7, courtyardWidth * 0.36, serviceDepth * 0.24);
        g2.setColor(new Color(204, 188, 160));
        g2.fill(laundry);
        g2.setColor(new Color(182, 204, 214));
        g2.fill(cisternYard);
        g2.setColor(new Color(187, 203, 178));
        g2.fill(latrine);
        g2.setColor(new Color(174, 192, 138));
        g2.fill(dryingYard);

        Rectangle2D.Double refuse = orientedLocalRect(rect, entrance, courtyardMargin + courtyardWidth * 0.86, cursor + serviceDepth * 0.16, courtyardWidth * 0.1, serviceDepth * 0.38);
        g2.setColor(new Color(191, 170, 140));
        g2.fill(refuse);

        Rectangle2D.Double serviceExit = orientedLocalRect(rect, entrance, courtyardMargin + courtyardWidth * 0.24, cursor + serviceDepth * 0.78, courtyardWidth * 0.52, serviceDepth * 0.22);
        g2.setColor(WALKWAY_TONE);
        g2.fill(serviceExit);

        g2.setColor(WALL_TONE);
        g2.draw(serviceCourt);
        g2.draw(laundry);
        g2.draw(cisternYard);
        g2.draw(latrine);
        g2.draw(dryingYard);
        g2.draw(refuse);
        g2.draw(serviceExit);

        g2.dispose();
    }


    private void drawShopPlan(Graphics2D g, Rectangle2D.Double rect, Edge entrance, EnumSet<Edge> partyWalls) {
        Graphics2D g2 = (Graphics2D) g.create();
        double doorSpan = orientedSpan(rect, entrance) * 0.38;
        drawOuterWall(g2, rect, entrance, doorSpan, partyWalls);

        double depth = perpendicularSpan(rect, entrance);
        double frontDepth = Math.max(24, depth * 0.18);
        double salesDepth = Math.max(48, depth * 0.32);
        double rearDepth = Math.max(32, depth - frontDepth - salesDepth);

        Rectangle2D.Double arcade = createEdgeStrip(rect, entrance, frontDepth);
        g2.setColor(WALKWAY_TONE);
        g2.fill(arcade);

        Rectangle2D.Double salesHall = orientedLocalRect(rect, entrance, 0, frontDepth, orientedSpan(rect, entrance), salesDepth);
        g2.setColor(new Color(224, 208, 180));
        g2.fill(salesHall);

        Rectangle2D.Double counters = orientedLocalRect(rect, entrance, 12, frontDepth + salesDepth * 0.15, orientedSpan(rect, entrance) - 24, salesDepth * 0.18);
        g2.setColor(new Color(204, 188, 160));
        g2.fill(counters);

        Rectangle2D.Double storerooms = createEdgeStrip(rect, opposite(entrance), rearDepth);
        g2.setColor(new Color(207, 195, 166));
        g2.fill(storerooms);

        Rectangle2D.Double offices = orientedLocalRect(rect, entrance, 0, frontDepth + salesDepth, orientedSpan(rect, entrance) * 0.35, rearDepth);
        Rectangle2D.Double workshop = orientedLocalRect(rect, entrance, orientedSpan(rect, entrance) - offices.width, frontDepth + salesDepth, offices.width, rearDepth);
        g2.setColor(new Color(210, 194, 170));
        g2.fill(offices);
        g2.fill(workshop);

        boolean horizontal = entrance == Edge.NORTH || entrance == Edge.SOUTH;
        int stalls = Math.max(3, (int) Math.round((horizontal ? rect.width : rect.height) / 120.0 * 3));
        drawStripSubdivisions(g2, salesHall, horizontal, stalls);

        Rectangle2D.Double servicePassage = createConnector(rect, storerooms, entrance, 0.25);
        g2.setColor(WALKWAY_TONE);
        g2.fill(servicePassage);

        g2.setColor(WALL_TONE);
        g2.setStroke(new BasicStroke(2.7f));
        g2.draw(arcade);
        g2.draw(storerooms);
        g2.draw(offices);
        g2.draw(workshop);
        g2.draw(counters);

        g2.dispose();
    }

    private void drawChurchPlan(Graphics2D g, Rectangle2D.Double rect, Edge entrance, EnumSet<Edge> partyWalls) {
        Graphics2D g2 = (Graphics2D) g.create();
        double doorSpan = orientedSpan(rect, entrance) * 0.28;
        drawOuterWall(g2, rect, entrance, doorSpan, partyWalls);

        double span = orientedSpan(rect, entrance);
        double depth = perpendicularSpan(rect, entrance);

        double exonarthexDepth = clamp(depth * 0.08, 18, depth * 0.12);
        double narthexDepth = clamp(depth * 0.12, 26, depth * 0.18);
        double naveDepth = clamp(depth * 0.44, 96, depth * 0.54);
        double sanctuaryDepth = clamp(depth * 0.16, 42, depth * 0.22);
        double apseDepth = Math.max(44, depth - (exonarthexDepth + narthexDepth + naveDepth + sanctuaryDepth));

        double naveWidth = Math.min(span * 0.64, span - 96);
        double naveMargin = Math.max((span - naveWidth) / 2.0, 18);
        double aisleWidth = clamp(naveWidth * 0.22, 24, naveWidth * 0.3);
        double naveCoreWidth = naveWidth - 2 * aisleWidth;
        double sideRangeWidth = clamp(span * 0.08, 20, span * 0.14);

        double cursor = 0;

        Rectangle2D.Double forecourt = orientedLocalRect(rect, entrance, naveMargin - sideRangeWidth * 0.4, Math.max(0, cursor - exonarthexDepth * 0.6), naveWidth + sideRangeWidth * 0.8, exonarthexDepth * 1.5);
        g2.setColor(new Color(214, 200, 172));
        g2.fill(forecourt);

        Rectangle2D.Double exonarthex = orientedLocalRect(rect, entrance, naveMargin, cursor, naveWidth, exonarthexDepth);
        g2.setColor(WALKWAY_TONE);
        g2.fill(exonarthex);
        cursor += exonarthexDepth;

        Rectangle2D.Double narthex = orientedLocalRect(rect, entrance, naveMargin, cursor, naveWidth, narthexDepth);
        g2.setColor(new Color(214, 198, 163));
        g2.fill(narthex);
        cursor += narthexDepth;

        Rectangle2D.Double nave = orientedLocalRect(rect, entrance, naveMargin, cursor, naveWidth, naveDepth);
        g2.setColor(new Color(230, 219, 194));
        g2.fill(nave);

        Rectangle2D.Double northAisle = orientedLocalRect(rect, entrance, naveMargin, cursor, aisleWidth, naveDepth);
        Rectangle2D.Double southAisle = orientedLocalRect(rect, entrance, naveMargin + aisleWidth + naveCoreWidth, cursor, aisleWidth, naveDepth);
        g2.setColor(new Color(224, 210, 182));
        g2.fill(northAisle);
        g2.fill(southAisle);

        Rectangle2D.Double naveCore = orientedLocalRect(rect, entrance, naveMargin + aisleWidth, cursor, naveCoreWidth, naveDepth);
        g2.setColor(new Color(228, 214, 188));
        g2.fill(naveCore);

        Rectangle2D.Double galleriesNorth = orientedLocalRect(rect, entrance, naveMargin, cursor + naveDepth * 0.12, aisleWidth * 0.6, naveDepth * 0.76);
        Rectangle2D.Double galleriesSouth = orientedLocalRect(rect, entrance, naveMargin + aisleWidth + naveCoreWidth + aisleWidth * 0.4, cursor + naveDepth * 0.12, aisleWidth * 0.6, naveDepth * 0.76);
        g2.setColor(new Color(214, 200, 172));
        g2.fill(galleriesNorth);
        g2.fill(galleriesSouth);

        Rectangle2D.Double transept = createTransept(nave, entrance, naveDepth * 0.32);
        g2.setColor(new Color(226, 214, 188));
        g2.fill(transept);

        Rectangle2D.Double crossing = insetRect(transept, transept.width * 0.32, transept.height * 0.32);
        g2.setColor(new Color(221, 206, 178));
        g2.fill(crossing);

        double domeRadius = Math.min(crossing.width, crossing.height) * 0.32;
        Ellipse2D.Double dome = new Ellipse2D.Double(crossing.getCenterX() - domeRadius, crossing.getCenterY() - domeRadius, domeRadius * 2, domeRadius * 2);
        g2.setColor(new Color(205, 188, 160));
        g2.fill(dome);
        g2.setColor(WALL_TONE);
        g2.draw(dome);

        Rectangle2D.Double ambo = orientedLocalRect(rect, entrance, naveMargin + aisleWidth + naveCoreWidth * 0.3, cursor + naveDepth * 0.58, naveCoreWidth * 0.4, naveDepth * 0.08);
        g2.setColor(new Color(214, 198, 163));
        g2.fill(ambo);

        Rectangle2D.Double amboSteps = orientedLocalRect(rect, entrance, naveMargin + aisleWidth + naveCoreWidth * 0.32, cursor + naveDepth * 0.66, naveCoreWidth * 0.36, naveDepth * 0.04);
        g2.setColor(WALKWAY_TONE);
        g2.fill(amboSteps);

        Rectangle2D.Double sideChapelNorth = orientedLocalRect(rect, entrance, naveMargin - sideRangeWidth * 0.8, crossing.y + crossing.height * 0.2, sideRangeWidth * 0.8, crossing.height * 0.6);
        Rectangle2D.Double sideChapelSouth = orientedLocalRect(rect, entrance, naveMargin + naveWidth, crossing.y + crossing.height * 0.2, sideRangeWidth * 0.8, crossing.height * 0.6);
        g2.setColor(new Color(209, 194, 170));
        g2.fill(sideChapelNorth);
        g2.fill(sideChapelSouth);

        Rectangle2D.Double prothesis = orientedLocalRect(rect, entrance, naveMargin, cursor + naveDepth + sanctuaryDepth * 0.18, aisleWidth, sanctuaryDepth * 0.6);
        Rectangle2D.Double diaconicon = orientedLocalRect(rect, entrance, naveMargin + aisleWidth + naveCoreWidth, cursor + naveDepth + sanctuaryDepth * 0.18, aisleWidth, sanctuaryDepth * 0.6);
        g2.setColor(new Color(210, 196, 168));
        g2.fill(prothesis);
        g2.fill(diaconicon);

        Rectangle2D.Double presbytery = orientedLocalRect(rect, entrance, naveMargin + aisleWidth * 0.5, cursor + naveDepth, naveWidth - aisleWidth, sanctuaryDepth);
        g2.setColor(new Color(221, 209, 180));
        g2.fill(presbytery);

        Rectangle2D.Double iconostasis = orientedLocalRect(rect, entrance, naveMargin + aisleWidth, cursor + naveDepth + sanctuaryDepth * 0.16, naveCoreWidth, sanctuaryDepth * 0.12);
        g2.setColor(new Color(204, 188, 160));
        g2.fill(iconostasis);

        Rectangle2D.Double altar = orientedLocalRect(rect, entrance, naveMargin + aisleWidth + naveCoreWidth * 0.32, cursor + naveDepth + sanctuaryDepth * 0.32, naveCoreWidth * 0.36, sanctuaryDepth * 0.28);
        g2.setColor(new Color(214, 200, 172));
        g2.fill(altar);

        Rectangle2D.Double apse = createApse(presbytery, entrance, apseDepth);
        g2.setColor(new Color(221, 209, 180));
        g2.fill(apse);

        Rectangle2D.Double synthronon = insetRect(apse, apse.width * 0.2, apse.height * 0.2);
        g2.setColor(new Color(214, 198, 163));
        g2.fill(synthronon);

        Rectangle2D.Double ambulatory = insetRect(apse, apse.width * 0.08, apse.height * 0.1);
        g2.setColor(WALL_TONE);
        g2.draw(ambulatory);

        Rectangle2D.Double baptistery = orientedLocalRect(rect, entrance, naveMargin - sideRangeWidth * 0.95, exonarthex.y + exonarthex.height * 0.4, sideRangeWidth * 0.9, narthexDepth * 0.9);
        g2.setColor(new Color(207, 191, 165));
        g2.fill(baptistery);
        double fontRadius = Math.min(baptistery.width, baptistery.height) * 0.35;
        Ellipse2D.Double font = new Ellipse2D.Double(baptistery.getCenterX() - fontRadius, baptistery.getCenterY() - fontRadius, fontRadius * 2, fontRadius * 2);
        g2.setColor(new Color(166, 198, 212));
        g2.fill(font);
        g2.setColor(WALL_TONE);
        g2.draw(font);

        Rectangle2D.Double diaconalHall = orientedLocalRect(rect, entrance, naveMargin + naveWidth, exonarthex.y + exonarthex.height * 0.3, sideRangeWidth * 0.9, narthexDepth * 1.1);
        g2.setColor(new Color(210, 196, 168));
        g2.fill(diaconalHall);

        Rectangle2D.Double cloister = orientedLocalRect(rect, entrance, naveMargin + naveWidth, cursor - narthexDepth * 0.6, sideRangeWidth * 0.9, naveDepth * 0.35);
        g2.setColor(WALKWAY_TONE);
        g2.fill(cloister);

        Rectangle2D.Double sacristy = orientedLocalRect(rect, entrance, naveMargin + naveWidth - aisleWidth * 0.4, cursor + naveDepth + sanctuaryDepth * 0.1, aisleWidth * 0.4, sanctuaryDepth * 0.7);
        g2.setColor(new Color(207, 191, 165));
        g2.fill(sacristy);

        drawColonnade(g2, nave, entrance);

        g2.setColor(WALL_TONE);
        g2.setStroke(new BasicStroke(2.9f));
        g2.draw(nave);
        g2.draw(northAisle);
        g2.draw(southAisle);
        g2.draw(transept);
        g2.draw(sideChapelNorth);
        g2.draw(sideChapelSouth);
        g2.draw(presbytery);
        g2.draw(prothesis);
        g2.draw(diaconicon);
        g2.draw(apse);
        g2.draw(iconostasis);
        g2.draw(altar);
        g2.draw(baptistery);
        g2.draw(diaconalHall);
        g2.draw(cloister);
        g2.draw(sacristy);
        g2.draw(exonarthex);
        g2.draw(narthex);
        g2.draw(ambo);
        g2.draw(amboSteps);

        g2.dispose();
    }


    private void drawParkPlan(Graphics2D g, Rectangle2D.Double rect) {
        Graphics2D g2 = (Graphics2D) g.create();
        g2.setColor(new Color(156, 192, 132));
        g2.fill(rect);

        g2.setColor(new Color(120, 90, 60, 180));
        g2.setStroke(new BasicStroke(4.6f));
        g2.draw(rect);

        g2.setStroke(new BasicStroke(6.4f));
        Rectangle2D.Double crossPathH = new Rectangle2D.Double(rect.x, rect.getCenterY() - rect.height * 0.05, rect.width, rect.height * 0.1);
        Rectangle2D.Double crossPathV = new Rectangle2D.Double(rect.getCenterX() - rect.width * 0.05, rect.y, rect.width * 0.1, rect.height);
        g2.setColor(new Color(214, 198, 163));
        g2.fill(crossPathH);
        g2.fill(crossPathV);

        g2.setColor(new Color(116, 156, 104));
        for (int i = 0; i < 14; i++) {
            double x = rect.x + rect.width * (0.1 + 0.8 * random.nextDouble());
            double y = rect.y + rect.height * (0.1 + 0.8 * random.nextDouble());
            g2.fill(new Rectangle2D.Double(x, y, 8 + random.nextInt(8), 8 + random.nextInt(8)));
        }

        g2.dispose();
    }

    private void drawOuterWall(Graphics2D g, Rectangle2D.Double rect, Edge entrance, double doorSpan, EnumSet<Edge> partyWalls) {
        g.setColor(WALL_TONE);
        BasicStroke exterior = new BasicStroke(4.8f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER);
        BasicStroke shared = new BasicStroke(3.4f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER);
        if (entrance == null) {
            g.setStroke(partyWalls.isEmpty() ? exterior : shared);
            g.draw(rect);
            return;
        }
        double doorCenter;
        switch (entrance) {
            case NORTH:
                doorCenter = rect.getCenterX();
                g.setStroke(partyWalls.contains(Edge.NORTH) ? shared : exterior);
                drawLineWithGap(g, rect.x, rect.y, rect.getMaxX(), rect.y, doorCenter, doorSpan, true);
                g.setStroke(partyWalls.contains(Edge.WEST) ? shared : exterior);
                g.draw(new Line2D.Double(rect.x, rect.y, rect.x, rect.getMaxY()));
                g.setStroke(partyWalls.contains(Edge.EAST) ? shared : exterior);
                g.draw(new Line2D.Double(rect.getMaxX(), rect.y, rect.getMaxX(), rect.getMaxY()));
                g.setStroke(partyWalls.contains(Edge.SOUTH) ? shared : exterior);
                g.draw(new Line2D.Double(rect.x, rect.getMaxY(), rect.getMaxX(), rect.getMaxY()));
                break;
            case SOUTH:
                doorCenter = rect.getCenterX();
                g.setStroke(partyWalls.contains(Edge.NORTH) ? shared : exterior);
                g.draw(new Line2D.Double(rect.x, rect.y, rect.getMaxX(), rect.y));
                g.setStroke(partyWalls.contains(Edge.WEST) ? shared : exterior);
                g.draw(new Line2D.Double(rect.x, rect.y, rect.x, rect.getMaxY()));
                g.setStroke(partyWalls.contains(Edge.EAST) ? shared : exterior);
                g.draw(new Line2D.Double(rect.getMaxX(), rect.y, rect.getMaxX(), rect.getMaxY()));
                g.setStroke(partyWalls.contains(Edge.SOUTH) ? shared : exterior);
                drawLineWithGap(g, rect.x, rect.getMaxY(), rect.getMaxX(), rect.getMaxY(), doorCenter, doorSpan, true);
                break;
            case EAST:
                doorCenter = rect.getCenterY();
                g.setStroke(partyWalls.contains(Edge.NORTH) ? shared : exterior);
                g.draw(new Line2D.Double(rect.x, rect.y, rect.getMaxX(), rect.y));
                g.setStroke(partyWalls.contains(Edge.EAST) ? shared : exterior);
                drawLineWithGap(g, rect.getMaxX(), rect.y, rect.getMaxX(), rect.getMaxY(), doorCenter, doorSpan, false);
                g.setStroke(partyWalls.contains(Edge.SOUTH) ? shared : exterior);
                g.draw(new Line2D.Double(rect.x, rect.getMaxY(), rect.getMaxX(), rect.getMaxY()));
                g.setStroke(partyWalls.contains(Edge.WEST) ? shared : exterior);
                g.draw(new Line2D.Double(rect.x, rect.y, rect.x, rect.getMaxY()));
                break;
            case WEST:
            default:
                doorCenter = rect.getCenterY();
                g.setStroke(partyWalls.contains(Edge.WEST) ? shared : exterior);
                drawLineWithGap(g, rect.x, rect.y, rect.x, rect.getMaxY(), doorCenter, doorSpan, false);
                g.setStroke(partyWalls.contains(Edge.EAST) ? shared : exterior);
                g.draw(new Line2D.Double(rect.getMaxX(), rect.y, rect.getMaxX(), rect.getMaxY()));
                g.setStroke(partyWalls.contains(Edge.NORTH) ? shared : exterior);
                g.draw(new Line2D.Double(rect.x, rect.y, rect.getMaxX(), rect.y));
                g.setStroke(partyWalls.contains(Edge.SOUTH) ? shared : exterior);
                g.draw(new Line2D.Double(rect.x, rect.getMaxY(), rect.getMaxX(), rect.getMaxY()));
                break;
        }
    }

    private Rectangle2D.Double insetRect(Rectangle2D.Double rect, double insetX, double insetY) {
        return new Rectangle2D.Double(rect.x + insetX, rect.y + insetY, rect.width - 2 * insetX, rect.height - 2 * insetY);
    }

    private Rectangle2D.Double orientedLocalRect(Rectangle2D.Double rect, Edge entrance, double localX, double localY, double width, double height) {
        width = Math.max(0, width);
        height = Math.max(0, height);
        switch (entrance) {
            case NORTH:
                return new Rectangle2D.Double(
                        rect.getMaxX() - (localX + width),
                        rect.y + localY,
                        width,
                        height
                );
            case EAST:
                return new Rectangle2D.Double(
                        rect.getMaxX() - (localY + height),
                        rect.getMaxY() - (localX + width),
                        height,
                        width
                );
            case WEST:
                return new Rectangle2D.Double(
                        rect.x + localY,
                        rect.y + localX,
                        height,
                        width
                );
            case SOUTH:
            default:
                return new Rectangle2D.Double(
                        rect.x + localX,
                        rect.getMaxY() - (localY + height),
                        width,
                        height
                );
        }
    }

    private Rectangle2D.Double createTransept(Rectangle2D.Double nave, Edge entrance, double thickness) {
        double span = orientedSpan(nave, entrance);
        double depth = perpendicularSpan(nave, entrance);
        double clampedThickness = Math.min(thickness, depth);
        double start = Math.max(0, depth * 0.52 - clampedThickness / 2.0);
        if (start + clampedThickness > depth) {
            start = depth - clampedThickness;
        }
        return orientedLocalRect(nave, entrance, 0, start, span, clampedThickness);
    }

    private Rectangle2D.Double createApse(Rectangle2D.Double nave, Edge entrance, double depth) {
        double span = orientedSpan(nave, entrance);
        double margin = Math.max(12, span * 0.18);
        double width = Math.max(span - margin * 2, span * 0.45);
        double start = Math.max(0, perpendicularSpan(nave, entrance) - depth);
        return orientedLocalRect(nave, entrance, (span - width) / 2.0, start, width, Math.min(depth, perpendicularSpan(nave, entrance)));
    }

    private Rectangle2D.Double createEdgeStrip(Rectangle2D.Double rect, Edge edge, double depth) {
        switch (edge) {
            case NORTH:
                return new Rectangle2D.Double(rect.x, rect.y, rect.width, depth);
            case SOUTH:
                return new Rectangle2D.Double(rect.x, rect.getMaxY() - depth, rect.width, depth);
            case EAST:
                return new Rectangle2D.Double(rect.getMaxX() - depth, rect.y, depth, rect.height);
            case WEST:
            default:
                return new Rectangle2D.Double(rect.x, rect.y, depth, rect.height);
        }
    }

    private double clamp(double value, double min, double max) {
        if (max < min) {
            return min;
        }
        return Math.max(min, Math.min(max, value));
    }

    private Rectangle2D.Double createConnector(Rectangle2D.Double outer, Rectangle2D.Double inner, Edge edge, double ratio) {
        double width;
        double height;
        switch (edge) {
            case NORTH:
                width = inner.width * ratio;
                height = Math.max(inner.y - outer.y, 12);
                return new Rectangle2D.Double(inner.getCenterX() - width / 2.0, inner.y - height, width, height);
            case SOUTH:
                width = inner.width * ratio;
                height = Math.max(outer.getMaxY() - inner.getMaxY(), 12);
                return new Rectangle2D.Double(inner.getCenterX() - width / 2.0, inner.getMaxY(), width, height);
            case EAST:
                width = Math.max(outer.getMaxX() - inner.getMaxX(), 12);
                height = inner.height * ratio;
                return new Rectangle2D.Double(inner.getMaxX(), inner.getCenterY() - height / 2.0, width, height);
            case WEST:
            default:
                width = Math.max(inner.x - outer.x, 12);
                height = inner.height * ratio;
                return new Rectangle2D.Double(inner.x - width, inner.getCenterY() - height / 2.0, width, height);
        }
    }

    private Rectangle2D.Double createWing(Rectangle2D.Double outer, Rectangle2D.Double inner, Edge side) {
        switch (side) {
            case NORTH:
                return new Rectangle2D.Double(inner.x, outer.y, inner.width, Math.max(0, inner.y - outer.y));
            case SOUTH:
                return new Rectangle2D.Double(inner.x, inner.getMaxY(), inner.width, Math.max(0, outer.getMaxY() - inner.getMaxY()));
            case EAST:
                return new Rectangle2D.Double(inner.getMaxX(), inner.y, Math.max(0, outer.getMaxX() - inner.getMaxX()), inner.height);
            case WEST:
            default:
                return new Rectangle2D.Double(outer.x, inner.y, Math.max(0, inner.x - outer.x), inner.height);
        }
    }

    private Rectangle2D.Double middleBand(Rectangle2D.Double outer, Rectangle2D.Double frontStrip, Rectangle2D.Double rearStrip, Edge entrance) {
        if (entrance == Edge.NORTH || entrance == Edge.SOUTH) {
            double y = frontStrip.y + frontStrip.height;
            double height = outer.height - frontStrip.height - rearStrip.height;
            return new Rectangle2D.Double(outer.x, y, outer.width, Math.max(0, height));
        } else {
            double x = frontStrip.x + frontStrip.width;
            double width = outer.width - frontStrip.width - rearStrip.width;
            return new Rectangle2D.Double(x, outer.y, Math.max(0, width), outer.height);
        }
    }

    private void drawWingRooms(Graphics2D g, Rectangle2D.Double wing, boolean vertical, int rooms) {
        if (wing.width <= 0 || wing.height <= 0 || rooms <= 0) {
            return;
        }
        g.setColor(new Color(221, 205, 176));
        g.fill(wing);

        g.setColor(WALL_TONE);
        g.setStroke(new BasicStroke(2.6f));
        if (rooms <= 1) {
            return;
        }
        if (vertical) {
            double step = wing.height / rooms;
            for (int i = 1; i < rooms; i++) {
                double y = wing.y + i * step;
                g.draw(new Line2D.Double(wing.x, y, wing.getMaxX(), y));
            }
        } else {
            double step = wing.width / rooms;
            for (int i = 1; i < rooms; i++) {
                double x = wing.x + i * step;
                g.draw(new Line2D.Double(x, wing.y, x, wing.getMaxY()));
            }
        }
    }

    private void drawStripSubdivisions(Graphics2D g, Rectangle2D.Double area, boolean horizontal, int partitions) {
        if (area.width <= 0 || area.height <= 0 || partitions <= 0) {
            return;
        }
        g.setColor(new Color(221, 206, 179));
        g.fill(area);

        g.setColor(WALL_TONE);
        g.setStroke(new BasicStroke(2.6f));
        if (partitions <= 1) {
            return;
        }
        if (horizontal) {
            double step = area.width / partitions;
            for (int i = 1; i < partitions; i++) {
                double x = area.x + i * step;
                g.draw(new Line2D.Double(x, area.y, x, area.getMaxY()));
            }
        } else {
            double step = area.height / partitions;
            for (int i = 1; i < partitions; i++) {
                double y = area.y + i * step;
                g.draw(new Line2D.Double(area.x, y, area.getMaxX(), y));
            }
        }
    }

    private void drawRectOutlineWithDoor(Graphics2D g, Rectangle2D.Double rect, Edge doorwaySide, Rectangle2D.Double connector) {
        g.setColor(WALL_TONE);
        g.setStroke(new BasicStroke(2.9f));
        if (doorwaySide == null) {
            g.draw(rect);
            return;
        }
        double gapCenter;
        double gapWidth;
        switch (doorwaySide) {
            case NORTH:
                gapCenter = connector != null ? connector.getCenterX() : rect.getCenterX();
                gapWidth = connector != null ? connector.width : rect.width * 0.25;
                drawLineWithGap(g, rect.x, rect.y, rect.getMaxX(), rect.y, gapCenter, gapWidth, true);
                g.draw(new Line2D.Double(rect.x, rect.y, rect.x, rect.getMaxY()));
                g.draw(new Line2D.Double(rect.getMaxX(), rect.y, rect.getMaxX(), rect.getMaxY()));
                g.draw(new Line2D.Double(rect.x, rect.getMaxY(), rect.getMaxX(), rect.getMaxY()));
                break;
            case SOUTH:
                gapCenter = connector != null ? connector.getCenterX() : rect.getCenterX();
                gapWidth = connector != null ? connector.width : rect.width * 0.25;
                g.draw(new Line2D.Double(rect.x, rect.y, rect.getMaxX(), rect.y));
                g.draw(new Line2D.Double(rect.x, rect.y, rect.x, rect.getMaxY()));
                g.draw(new Line2D.Double(rect.getMaxX(), rect.y, rect.getMaxX(), rect.getMaxY()));
                drawLineWithGap(g, rect.x, rect.getMaxY(), rect.getMaxX(), rect.getMaxY(), gapCenter, gapWidth, true);
                break;
            case EAST:
                gapCenter = connector != null ? connector.getCenterY() : rect.getCenterY();
                gapWidth = connector != null ? connector.height : rect.height * 0.25;
                g.draw(new Line2D.Double(rect.x, rect.y, rect.getMaxX(), rect.y));
                drawLineWithGap(g, rect.getMaxX(), rect.y, rect.getMaxX(), rect.getMaxY(), gapCenter, gapWidth, false);
                g.draw(new Line2D.Double(rect.x, rect.getMaxY(), rect.getMaxX(), rect.getMaxY()));
                g.draw(new Line2D.Double(rect.x, rect.y, rect.x, rect.getMaxY()));
                break;
            case WEST:
            default:
                gapCenter = connector != null ? connector.getCenterY() : rect.getCenterY();
                gapWidth = connector != null ? connector.height : rect.height * 0.25;
                drawLineWithGap(g, rect.x, rect.y, rect.x, rect.getMaxY(), gapCenter, gapWidth, false);
                g.draw(new Line2D.Double(rect.getMaxX(), rect.y, rect.getMaxX(), rect.getMaxY()));
                g.draw(new Line2D.Double(rect.x, rect.y, rect.getMaxX(), rect.y));
                g.draw(new Line2D.Double(rect.x, rect.getMaxY(), rect.getMaxX(), rect.getMaxY()));
                break;
        }
    }

    private void drawEdgeWall(Graphics2D g, Rectangle2D.Double rect, Edge side, Rectangle2D.Double connector, double reliefRatio) {
        g.setColor(WALL_TONE);
        g.setStroke(new BasicStroke(3.0f));
        if (connector == null) {
            switch (side) {
                case NORTH:
                    g.draw(new Line2D.Double(rect.x, rect.y, rect.getMaxX(), rect.y));
                    break;
                case SOUTH:
                    g.draw(new Line2D.Double(rect.x, rect.getMaxY(), rect.getMaxX(), rect.getMaxY()));
                    break;
                case EAST:
                    g.draw(new Line2D.Double(rect.getMaxX(), rect.y, rect.getMaxX(), rect.getMaxY()));
                    break;
                case WEST:
                default:
                    g.draw(new Line2D.Double(rect.x, rect.y, rect.x, rect.getMaxY()));
                    break;
            }
            return;
        }
        double gapCenter;
        double gapWidth;
        switch (side) {
            case NORTH:
                gapCenter = connector.getCenterX();
                gapWidth = connector.width * (1 - reliefRatio);
                drawLineWithGap(g, rect.x, rect.y, rect.getMaxX(), rect.y, gapCenter, gapWidth, true);
                break;
            case SOUTH:
                gapCenter = connector.getCenterX();
                gapWidth = connector.width * (1 - reliefRatio);
                drawLineWithGap(g, rect.x, rect.getMaxY(), rect.getMaxX(), rect.getMaxY(), gapCenter, gapWidth, true);
                break;
            case EAST:
                gapCenter = connector.getCenterY();
                gapWidth = connector.height * (1 - reliefRatio);
                drawLineWithGap(g, rect.getMaxX(), rect.y, rect.getMaxX(), rect.getMaxY(), gapCenter, gapWidth, false);
                break;
            case WEST:
            default:
                gapCenter = connector.getCenterY();
                gapWidth = connector.height * (1 - reliefRatio);
                drawLineWithGap(g, rect.x, rect.y, rect.x, rect.getMaxY(), gapCenter, gapWidth, false);
                break;
        }
    }

    private void drawLineWithGap(Graphics2D g, double x1, double y1, double x2, double y2, double gapCenter, double gapSpan, boolean horizontal) {
        double half = gapSpan / 2.0;
        if (horizontal) {
            double start = Math.min(gapCenter - half, gapCenter + half);
            double end = Math.max(gapCenter - half, gapCenter + half);
            double minX = Math.min(x1, x2);
            double maxX = Math.max(x1, x2);
            double gapStart = Math.max(minX, start);
            double gapEnd = Math.min(maxX, end);
            if (gapStart > minX) {
                g.draw(new Line2D.Double(minX, y1, gapStart, y1));
            }
            if (gapEnd < maxX) {
                g.draw(new Line2D.Double(gapEnd, y1, maxX, y1));
            }
        } else {
            double start = Math.min(gapCenter - half, gapCenter + half);
            double end = Math.max(gapCenter - half, gapCenter + half);
            double minY = Math.min(y1, y2);
            double maxY = Math.max(y1, y2);
            double gapStart = Math.max(minY, start);
            double gapEnd = Math.min(maxY, end);
            if (gapStart > minY) {
                g.draw(new Line2D.Double(x1, minY, x1, gapStart));
            }
            if (gapEnd < maxY) {
                g.draw(new Line2D.Double(x1, gapEnd, x1, maxY));
            }
        }
    }

    private void drawColonnade(Graphics2D g, Rectangle2D.Double nave, Edge entrance) {
        g.setColor(new Color(155, 130, 98));
        boolean longitudinal = entrance == Edge.NORTH || entrance == Edge.SOUTH;
        int bays = 6;
        if (longitudinal) {
            double spacing = nave.height / (bays + 1);
            double leftX = nave.x + nave.width * 0.25;
            double rightX = nave.getMaxX() - nave.width * 0.25;
            double radius = Math.min(nave.width * 0.04, spacing * 0.28);
            for (int i = 1; i <= bays; i++) {
                double y = nave.y + i * spacing;
                g.fill(new Ellipse2D.Double(leftX - radius, y - radius, radius * 2, radius * 2));
                g.fill(new Ellipse2D.Double(rightX - radius, y - radius, radius * 2, radius * 2));
            }
            double crossingRadius = radius * 1.3;
            double crossingY = nave.getCenterY();
            g.fill(new Ellipse2D.Double(leftX - crossingRadius, crossingY - crossingRadius, crossingRadius * 2, crossingRadius * 2));
            g.fill(new Ellipse2D.Double(rightX - crossingRadius, crossingY - crossingRadius, crossingRadius * 2, crossingRadius * 2));
        } else {
            double spacing = nave.width / (bays + 1);
            double topY = nave.y + nave.height * 0.25;
            double bottomY = nave.getMaxY() - nave.height * 0.25;
            double radius = Math.min(nave.height * 0.04, spacing * 0.28);
            for (int i = 1; i <= bays; i++) {
                double x = nave.x + i * spacing;
                g.fill(new Ellipse2D.Double(x - radius, topY - radius, radius * 2, radius * 2));
                g.fill(new Ellipse2D.Double(x - radius, bottomY - radius, radius * 2, radius * 2));
            }
            double crossingRadius = radius * 1.3;
            double crossingX = nave.getCenterX();
            g.fill(new Ellipse2D.Double(crossingX - crossingRadius, topY - crossingRadius, crossingRadius * 2, crossingRadius * 2));
            g.fill(new Ellipse2D.Double(crossingX - crossingRadius, bottomY - crossingRadius, crossingRadius * 2, crossingRadius * 2));
        }
    }

    private void drawPeristyleColonnade(Graphics2D g, Rectangle2D.Double peristyle) {
        g.setColor(new Color(155, 130, 98));
        int columns = 6;
        double spacingX = peristyle.width / (columns + 1);
        double spacingY = peristyle.height / (columns + 1);
        double size = Math.min(spacingX, spacingY) * 0.35;
        for (int i = 1; i <= columns; i++) {
            double x = peristyle.x + i * spacingX;
            double y = peristyle.y + peristyle.height * 0.18;
            g.fill(new Rectangle2D.Double(x - size / 2.0, y - size / 2.0, size, size));
            g.fill(new Rectangle2D.Double(x - size / 2.0, peristyle.getMaxY() - peristyle.height * 0.18 - size / 2.0, size, size));
        }
        for (int j = 1; j <= columns; j++) {
            double y = peristyle.y + j * spacingY;
            double x = peristyle.x + peristyle.width * 0.18;
            g.fill(new Rectangle2D.Double(x - size / 2.0, y - size / 2.0, size, size));
            g.fill(new Rectangle2D.Double(peristyle.getMaxX() - peristyle.width * 0.18 - size / 2.0, y - size / 2.0, size, size));
        }
    }

    private Edge findEntranceSide(Parcel parcel) {
        Rectangle2D.Double rect = parcel.rect;
        Edge bestEdge = null;
        double bestScore = -1;
        for (Edge edge : Edge.values()) {
            double score = 0;
            if (touchesPerimeter(rect, edge)) {
                score += edgeLength(rect, edge) * 2.0;
            }
            score += roadContactScore(rect, edge);
            if (score > bestScore) {
                bestScore = score;
                bestEdge = edge;
            }
        }
        if (bestEdge == null) {
            bestEdge = Edge.SOUTH;
        }
        return bestEdge;
    }

    private double roadContactScore(Rectangle2D.Double rect, Edge edge) {
        if (currentRoads == null) {
            return 0;
        }
        double score = 0;
        for (Road road : currentRoads) {
            if (touchesRoad(rect, edge, road.rect)) {
                score += overlapLength(rect, edge, road.rect) * 1.5;
            }
        }
        return score;
    }

    private double roadOverlapOnInterval(Rectangle2D.Double rect, Edge edge, double[] interval) {
        if (currentRoads == null || interval == null) {
            return 0;
        }
        double overlap = 0;
        for (Road road : currentRoads) {
            double[] roadInterval = edgeOverlapInterval(rect, edge, road.rect, true);
            if (roadInterval == null) {
                continue;
            }
            double start = Math.max(interval[0], roadInterval[0]);
            double end = Math.min(interval[1], roadInterval[1]);
            if (end > start) {
                overlap += end - start;
            }
        }
        double length = interval[1] - interval[0];
        if (overlap > length) {
            overlap = length;
        }
        return overlap;
    }

    private boolean touchesPerimeter(Rectangle2D.Double rect, Edge edge) {
        if (buildableArea == null) {
            return false;
        }
        double epsilon = 0.5;
        switch (edge) {
            case NORTH:
                return Math.abs(rect.y - buildableArea.y) < epsilon;
            case SOUTH:
                return Math.abs(rect.getMaxY() - buildableArea.getMaxY()) < epsilon;
            case EAST:
                return Math.abs(rect.getMaxX() - buildableArea.getMaxX()) < epsilon;
            case WEST:
            default:
                return Math.abs(rect.x - buildableArea.x) < epsilon;
        }
    }

    private boolean touchesRoad(Rectangle2D.Double rect, Edge edge, Rectangle2D.Double road) {
        double epsilon = 0.5;
        switch (edge) {
            case NORTH:
                if (Math.abs(rect.y - road.getMaxY()) < epsilon) {
                    return segmentsOverlap(rect.x, rect.getMaxX(), road.x, road.getMaxX());
                }
                break;
            case SOUTH:
                if (Math.abs(rect.getMaxY() - road.y) < epsilon) {
                    return segmentsOverlap(rect.x, rect.getMaxX(), road.x, road.getMaxX());
                }
                break;
            case EAST:
                if (Math.abs(rect.getMaxX() - road.x) < epsilon) {
                    return segmentsOverlap(rect.y, rect.getMaxY(), road.y, road.getMaxY());
                }
                break;
            case WEST:
            default:
                if (Math.abs(rect.x - road.getMaxX()) < epsilon) {
                    return segmentsOverlap(rect.y, rect.getMaxY(), road.y, road.getMaxY());
                }
                break;
        }
        return false;
    }

    private double[] edgeOverlapInterval(Rectangle2D.Double rect, Edge edge, Rectangle2D.Double other, boolean otherIsRoad) {
        double epsilon = 0.5;
        switch (edge) {
            case NORTH: {
                double otherEdge = otherIsRoad ? other.getMaxY() : other.getMaxY();
                if (Math.abs(rect.y - otherEdge) > epsilon) {
                    return null;
                }
                double start = Math.max(rect.x, other.x);
                double end = Math.min(rect.getMaxX(), other.getMaxX());
                if (end <= start) {
                    return null;
                }
                return new double[]{start - rect.x, end - rect.x};
            }
            case SOUTH: {
                double otherEdge = otherIsRoad ? other.y : other.y;
                if (Math.abs(rect.getMaxY() - otherEdge) > epsilon) {
                    return null;
                }
                double start = Math.max(rect.x, other.x);
                double end = Math.min(rect.getMaxX(), other.getMaxX());
                if (end <= start) {
                    return null;
                }
                return new double[]{start - rect.x, end - rect.x};
            }
            case EAST: {
                double otherEdge = otherIsRoad ? other.x : other.x;
                if (Math.abs(rect.getMaxX() - otherEdge) > epsilon) {
                    return null;
                }
                double start = Math.max(rect.y, other.y);
                double end = Math.min(rect.getMaxY(), other.getMaxY());
                if (end <= start) {
                    return null;
                }
                return new double[]{start - rect.y, end - rect.y};
            }
            case WEST:
            default: {
                double otherEdge = otherIsRoad ? other.getMaxX() : other.getMaxX();
                if (Math.abs(rect.x - otherEdge) > epsilon) {
                    return null;
                }
                double start = Math.max(rect.y, other.y);
                double end = Math.min(rect.getMaxY(), other.getMaxY());
                if (end <= start) {
                    return null;
                }
                return new double[]{start - rect.y, end - rect.y};
            }
        }
    }

    private boolean touchesParcel(Rectangle2D.Double rect, Edge edge, Rectangle2D.Double other) {
        double epsilon = 0.5;
        switch (edge) {
            case NORTH:
                if (Math.abs(rect.y - other.getMaxY()) < epsilon) {
                    return segmentsOverlap(rect.x, rect.getMaxX(), other.x, other.getMaxX());
                }
                break;
            case SOUTH:
                if (Math.abs(rect.getMaxY() - other.y) < epsilon) {
                    return segmentsOverlap(rect.x, rect.getMaxX(), other.x, other.getMaxX());
                }
                break;
            case EAST:
                if (Math.abs(rect.getMaxX() - other.x) < epsilon) {
                    return segmentsOverlap(rect.y, rect.getMaxY(), other.y, other.getMaxY());
                }
                break;
            case WEST:
            default:
                if (Math.abs(rect.x - other.getMaxX()) < epsilon) {
                    return segmentsOverlap(rect.y, rect.getMaxY(), other.y, other.getMaxY());
                }
                break;
        }
        return false;
    }

    private boolean segmentsOverlap(double a1, double a2, double b1, double b2) {
        double minA = Math.min(a1, a2);
        double maxA = Math.max(a1, a2);
        double minB = Math.min(b1, b2);
        double maxB = Math.max(b1, b2);
        return maxA > minB && maxB > minA;
    }

    private double overlapLength(Rectangle2D.Double rect, Edge edge, Rectangle2D.Double road) {
        if (edge == Edge.NORTH || edge == Edge.SOUTH) {
            double start = Math.max(rect.x, road.x);
            double end = Math.min(rect.getMaxX(), road.getMaxX());
            return Math.max(0, end - start);
        } else {
            double start = Math.max(rect.y, road.y);
            double end = Math.min(rect.getMaxY(), road.getMaxY());
            return Math.max(0, end - start);
        }
    }

    private double edgeLength(Rectangle2D.Double rect, Edge edge) {
        return (edge == Edge.NORTH || edge == Edge.SOUTH) ? rect.width : rect.height;
    }

    private double orientedSpan(Rectangle2D.Double rect, Edge entrance) {
        return (entrance == Edge.NORTH || entrance == Edge.SOUTH) ? rect.width : rect.height;
    }

    private double perpendicularSpan(Rectangle2D.Double rect, Edge entrance) {
        return (entrance == Edge.NORTH || entrance == Edge.SOUTH) ? rect.height : rect.width;
    }

    private Edge rotateClockwise(Edge edge) {
        switch (edge) {
            case NORTH:
                return Edge.EAST;
            case EAST:
                return Edge.SOUTH;
            case SOUTH:
                return Edge.WEST;
            case WEST:
            default:
                return Edge.NORTH;
        }
    }

    private Edge rotateCounterClockwise(Edge edge) {
        switch (edge) {
            case NORTH:
                return Edge.WEST;
            case WEST:
                return Edge.SOUTH;
            case SOUTH:
                return Edge.EAST;
            case EAST:
            default:
                return Edge.NORTH;
        }
    }

    private Edge opposite(Edge edge) {
        switch (edge) {
            case NORTH:
                return Edge.SOUTH;
            case SOUTH:
                return Edge.NORTH;
            case EAST:
                return Edge.WEST;
            case WEST:
            default:
                return Edge.EAST;
        }
    }

    private void annotateParcels(Graphics2D g, List<Parcel> parcels) {
        g.setFont(LABEL_FONT);
        for (Parcel parcel : parcels) {
            if (parcel.type == null) {
                continue;
            }
            String label = parcel.type.label;
            float x = (float) (parcel.rect.getCenterX() - g.getFontMetrics().stringWidth(label) / 2.0);
            float y = (float) (parcel.rect.getCenterY() + g.getFontMetrics().getAscent() / 2.5);
            g.setColor(new Color(30, 20, 10, 140));
            g.drawString(label, x, y);
        }
    }

    private LegendLayout measureLegend(Graphics2D g) {
        List<BuildingType> entries = new ArrayList<BuildingType>();
        for (BuildingType type : BuildingType.values()) {
            if (type != BuildingType.UNASSIGNED) {
                entries.add(type);
            }
        }
        if (entries.isEmpty()) {
            return null;
        }

        int padding = (int) Math.max(18, Math.round(20 * SCALE));
        int swatchSize = (int) Math.max(18, Math.round(30 * SCALE));
        int gap = (int) Math.max(10, Math.round(16 * SCALE));
        Font headerFont = LABEL_FONT.deriveFont(Font.BOLD, (float) Math.max(18f, (float) (20f * SCALE)));
        Font entryFont = LABEL_FONT.deriveFont(Font.PLAIN, (float) Math.max(16f, (float) (LABEL_FONT.getSize() * 0.8)));

        FontMetrics headerMetrics = g.getFontMetrics(headerFont);
        FontMetrics entryMetrics = g.getFontMetrics(entryFont);
        int headerHeight = headerMetrics.getHeight();
        int entryHeight = Math.max(swatchSize, entryMetrics.getHeight());
        int legendWidth = (int) Math.max(260, Math.round(320 * SCALE));
        int legendHeight = padding * 2 + headerHeight + gap + entries.size() * entryHeight + (entries.size() - 1) * gap;
        int corner = (int) Math.max(16, Math.round(24 * SCALE));

        return new LegendLayout(entries, padding, swatchSize, gap, corner, legendWidth, legendHeight,
                headerFont, entryFont, headerMetrics.getAscent(), headerHeight, entryMetrics.getAscent(), entryHeight);
    }

    private void drawLegend(Graphics2D g, LegendLayout layout, double x, double y) {
        Graphics2D g2 = (Graphics2D) g.create();
        g2.setFont(layout.headerFont);

        RoundRectangle2D.Double frame = new RoundRectangle2D.Double(x, y, layout.width, layout.height, layout.cornerRadius, layout.cornerRadius);
        g2.setColor(new Color(255, 250, 236, 235));
        g2.fill(frame);
        g2.setColor(new Color(120, 90, 60, 220));
        g2.setStroke(new BasicStroke((float) Math.max(2f, (float) (3f * SCALE / 2.0))));
        g2.draw(frame);

        int headerBaseline = (int) Math.round(y + layout.padding + layout.headerAscent);
        g2.drawString("Legend", (int) Math.round(x + layout.padding), headerBaseline);

        g2.setFont(layout.entryFont);
        int currentY = (int) Math.round(y + layout.padding + layout.headerHeight + layout.gap);
        double swatchCorner = Math.max(8, layout.cornerRadius / 2.0);
        for (BuildingType type : layout.entries) {
            RoundRectangle2D.Double swatch = new RoundRectangle2D.Double(x + layout.padding, currentY, layout.swatchSize, layout.swatchSize, swatchCorner, swatchCorner);
            g2.setColor(type.fillColor);
            g2.fill(swatch);
            g2.setColor(type.strokeColor);
            g2.setStroke(new BasicStroke((float) Math.max(2f, (float) (2.5f * SCALE / 1.5))));
            g2.draw(swatch);

            g2.setColor(new Color(50, 35, 20, 220));
            float textY = (float) (currentY + layout.swatchSize / 2.0 + layout.entryAscent / 2.5);
            g2.drawString(type.label, (float) (x + layout.padding + layout.swatchSize + layout.gap), textY);
            currentY += layout.entryHeight + layout.gap;
        }

        g2.dispose();
    }

    private double randomRange(double min, double max) {
        return min + random.nextDouble() * (max - min);
    }

    private static class LegendLayout {
        final List<BuildingType> entries;
        final int padding;
        final int swatchSize;
        final int gap;
        final int cornerRadius;
        final int width;
        final int height;
        final Font headerFont;
        final Font entryFont;
        final int headerAscent;
        final int headerHeight;
        final int entryAscent;
        final int entryHeight;

        LegendLayout(List<BuildingType> entries, int padding, int swatchSize, int gap, int cornerRadius, int width, int height,
                     Font headerFont, Font entryFont, int headerAscent, int headerHeight, int entryAscent, int entryHeight) {
            this.entries = entries;
            this.padding = padding;
            this.swatchSize = swatchSize;
            this.gap = gap;
            this.cornerRadius = cornerRadius;
            this.width = width;
            this.height = height;
            this.headerFont = headerFont;
            this.entryFont = entryFont;
            this.headerAscent = headerAscent;
            this.headerHeight = headerHeight;
            this.entryAscent = entryAscent;
            this.entryHeight = entryHeight;
        }
    }

    private static class Parcel {
        final Rectangle2D.Double rect;
        BuildingType type = BuildingType.UNASSIGNED;

        Parcel(Rectangle2D.Double rect) {
            this.rect = rect;
        }

        double area() {
            return rect.width * rect.height;
        }
    }

    private static class Road {
        final Rectangle2D.Double rect;
        final double width;

        Road(Rectangle2D.Double rect, double width) {
            this.rect = rect;
            this.width = width;
        }
    }

    private enum Edge {
        NORTH,
        EAST,
        SOUTH,
        WEST
    }

    private enum BuildingType {
        PRIVATE_HOUSE(new Color(196, 136, 96), new Color(120, 70, 50), "DOMUS"),
        TENEMENT(new Color(180, 120, 88), new Color(102, 60, 40), "INSULAE"),
        CHURCH(new Color(210, 188, 150), new Color(120, 80, 60), "BASILICA"),
        SHOP(new Color(200, 160, 110), new Color(130, 90, 60), "EMPORIA"),
        PARK(new Color(150, 185, 120), new Color(80, 110, 70), "HORTUS"),
        UNASSIGNED(new Color(0, 0, 0, 0), new Color(0, 0, 0, 0), "");

        final Color fillColor;
        final Color strokeColor;
        final String label;

        BuildingType(Color fillColor, Color strokeColor, String label) {
            this.fillColor = fillColor;
            this.strokeColor = strokeColor;
            this.label = label;
        }
    }
}